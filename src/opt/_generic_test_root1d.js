'use strict';

/* This file is part of ND.JS.
 *
 * ND.JS is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * ND.JS is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ND.JS. If not, see <http://www.gnu.org/licenses/>.
 */

import {forEachItemIn, CUSTOM_MATCHERS} from '../jasmine_utils';

import {linspace} from "../iter";

// BENCHMARK RESULTS
// -----------------
//
//   │  x_min  │  x_max  │ bisect  │ brent   │ illinois│ test_fn 
//   ┿━━━━━━━━━┿━━━━━━━━━┿━━━━━━━━━┿━━━━━━━━━┿━━━━━━━━━┿━━━━━━━━━
//   │   0.000 │   1.500 │      53 │      10 │       9 │
//   │  -1.000 │   3.000 │      56 │      12 │      12 │ 4*cos(x) - exp(x)
//   │  -1.500 │   6.000 │      57 │      13 │      19 │
//   ┼─────────┼─────────┼─────────┼─────────┼─────────┼─────────
//   │   4.000 │   6.500 │      53 │      10 │      10 │
//   │   2.000 │   8.000 │       3 │      11 │      12 │ { let s=0; for( let i=0; i++ < 10; ) s += exp(i*x/10) - exp(i/2); return s; }
//   │   0.000 │  15.000 │      55 │      14 │      15 │
//   │  -5.000 │  25.000 │      56 │      14 │      18 │
//   ┼─────────┼─────────┼─────────┼─────────┼─────────┼─────────
//   │   0.000 │   1.000 │      57 │      12 │      11 │ 2*x*exp(-20) + 1 - 2*exp(-20*x)
//   ┼─────────┼─────────┼─────────┼─────────┼─────────┼─────────
//   │   0.035 │   0.050 │      53 │      13 │      14 │
//   │   0.030 │   0.090 │      55 │      15 │      10 │ exp(1/x - 25) - 1
//   │   0.025 │   0.500 │      58 │      15 │      18 │
//   │   0.020 │   1.000 │      59 │      20 │      20 │
//   ┼─────────┼─────────┼─────────┼─────────┼─────────┼─────────
//   │   0.900 │   1.100 │       3 │      10 │      10 │
//   │   0.500 │   1.500 │       3 │      10 │      19 │ { let p=1e-8*(x-1); for( let i=0; i++ < 10; ) p *= (x*(x+1)+i); return p; }
//   │  -5.000 │   5.000 │      57 │      20 │      48 │
//   │  -5.000 │  10.000 │      57 │      21 │      68 │
//   ┼─────────┼─────────┼─────────┼─────────┼─────────┼─────────
//   │   0.095 │   1.000 │      59 │      14 │      14 │
//   │   0.075 │   0.150 │      55 │      15 │      18 │ 1e10 * (x**(1/x)) - 1
//   │   0.080 │   0.500 │      58 │      20 │      25 │
//   │   0.050 │   0.200 │      57 │      17 │      18 │
//   ┼─────────┼─────────┼─────────┼─────────┼─────────┼─────────
//   │   0.900 │   1.050 │      51 │       9 │      10 │
//   │   0.700 │   1.200 │      53 │      13 │      13 │ x**20 - 1
//   │   0.000 │   2.500 │      55 │      17 │      18 │
//   │  -0.500 │   5.000 │      57 │      19 │      21 │
//   ┼─────────┼─────────┼─────────┼─────────┼─────────┼─────────
//   │ 550.000 │ 560.000 │      49 │       9 │       8 │
//   │ 525.000 │ 590.000 │      52 │      11 │      12 │ exp(21e3/x) / (1.11e11*x*x)  -  1
//   │ 400.000 │ 600.000 │      53 │      14 │      15 │
//   │ 350.000 │ 850.000 │      55 │      17 │      18 │
//   ┼─────────┼─────────┼─────────┼─────────┼─────────┼─────────
//   │   0.005 │   0.020 │      55 │      11 │      10 │
//   │   0.001 │   0.050 │      57 │      13 │      12 │ 1/x + Math.log(x) - 100
//   │   0.000 │   0.100 │      52 │      14 │      13 │
//   │   0.001 │ 100.000 │      68 │      24 │      20 │
//   ┼─────────┼─────────┼─────────┼─────────┼─────────┼─────────
//   │   0.000 │   2.000 │       3 │       9 │      13 │
//   │  -4.000 │   2.000 │      56 │      13 │      12 │ exp(Math.exp(x)) - exp(Math.E)
//   │ -10.000 │   3.000 │      55 │      15 │      15 │
//   │   0.500 │   3.500 │      55 │      13 │      12 │
//   ┼─────────┼─────────┼─────────┼─────────┼─────────┼─────────
//   │   0.500 │   2.000 │      55 │      11 │      12 │
//   │   0.200 │   6.000 │      50 │      14 │      13 │ sin(0.01/x) - 0.01
//   │   0.050 │  20.000 │      58 │      16 │      14 │
//   │   0.004 │ 200.000 │      60 │      18 │      17 │
//   ┼─────────┼─────────┼─────────┼─────────┼─────────┼─────────
//   │   0.500 │   1.500 │       3 │      10 │       8 │ x*x*x - 1
//   ┼─────────┼─────────┼─────────┼─────────┼─────────┼─────────
//   │   0.100 │   1.000 │      56 │      14 │      12 │ x*x*(x*x/3 + sqrt(2)*sin(x))  -  sqrt(3)/18
//   ┼─────────┼─────────┼─────────┼─────────┼─────────┼─────────
//   │   0.100 │   1.000 │      56 │      12 │      14 │ 11 * (x**11) - 1
//   ┼─────────┼─────────┼─────────┼─────────┼─────────┼─────────
//   │  -1.800 │   0.000 │      54 │      10 │      10 │ x*x*x + 1
//   ┼─────────┼─────────┼─────────┼─────────┼─────────┼─────────
//   │   2.000 │   3.000 │      54 │       9 │       9 │ x*x*x - 3*x - 5
//   ┼─────────┼─────────┼─────────┼─────────┼─────────┼─────────
//   │   0.000 │   1.000 │      56 │      10 │      11 │ 2*x*exp(- 5) + 1 - 2*exp(- 5*x)
//   ┼─────────┼─────────┼─────────┼─────────┼─────────┼─────────
//   │   0.000 │   1.000 │      57 │      13 │      13 │ 2*x*exp(-10) + 1 - 2*exp(-10*x)
//   ┼─────────┼─────────┼─────────┼─────────┼─────────┼─────────
//   │   0.000 │   1.000 │      59 │      10 │      10 │ (1 + (1- 5)**2)*x*x  -  (1- 5*x)**2
//   ┼─────────┼─────────┼─────────┼─────────┼─────────┼─────────
//   │   0.000 │   1.000 │      60 │      10 │      10 │ (1 + (1-10)**2)*x*x  -  (1-10*x)**2
//   ┼─────────┼─────────┼─────────┼─────────┼─────────┼─────────
//   │   0.000 │   1.000 │      59 │       9 │       9 │ (1 + (1-20)**2)*x*x  -  (1-20*x)**2
//   ┼─────────┼─────────┼─────────┼─────────┼─────────┼─────────
//   │   0.000 │   1.000 │      57 │      10 │      10 │ x*x - (1-x)** 5
//   ┼─────────┼─────────┼─────────┼─────────┼─────────┼─────────
//   │   0.000 │   1.000 │      58 │      12 │      11 │ x*x - (1-x)**10
//   ┼─────────┼─────────┼─────────┼─────────┼─────────┼─────────
//   │   0.000 │   1.000 │      57 │      13 │      12 │ x*x - (1-x)**20
//   ┼─────────┼─────────┼─────────┼─────────┼─────────┼─────────
//   │   0.000 │   1.000 │      63 │       8 │       9 │ (1 + (1 - 5)**4)*x  -  (1 - 5*x)**4
//   ┼─────────┼─────────┼─────────┼─────────┼─────────┼─────────
//   │   0.000 │   1.000 │      68 │       8 │       9 │ (1 + (1 -10)**4)*x  -  (1 -10*x)**4
//   ┼─────────┼─────────┼─────────┼─────────┼─────────┼─────────
//   │   0.000 │   1.000 │      71 │       7 │       7 │ (1 + (1 -20)**4)*x  -  (1 -20*x)**4
//   ┼─────────┼─────────┼─────────┼─────────┼─────────┼─────────
//   │   0.000 │   1.000 │      56 │       9 │      10 │ exp(- 5*x)*(x-1) + x** 5
//   ┼─────────┼─────────┼─────────┼─────────┼─────────┼─────────
//   │   0.000 │   1.000 │      56 │      10 │      10 │ exp(-10*x)*(x-1) + x**10
//   ┼─────────┼─────────┼─────────┼─────────┼─────────┼─────────
//   │   0.000 │   1.000 │      56 │      13 │      11 │ exp(-20*x)*(x-1) + x**20
//   ┼─────────┼─────────┼─────────┼─────────┼─────────┼─────────
//   │   0.000 │   1.000 │      56 │      11 │       9 │ x*x + sin(x / 5) - 1/4
//   ┼─────────┼─────────┼─────────┼─────────┼─────────┼─────────
//   │   0.000 │   1.000 │      55 │      10 │      11 │ x*x + sin(x /10) - 1/4
//   ┼─────────┼─────────┼─────────┼─────────┼─────────┼─────────
//   │   0.000 │   1.000 │      53 │      10 │       9 │ x*x + sin(x /20) - 1/4
//   ┼─────────┼─────────┼─────────┼─────────┼─────────┼─────────
//   │   2.500 │   3.500 │       3 │     149 │     120 │ (x+2) * (x+1) * (x-3)**3
//   ┼─────────┼─────────┼─────────┼─────────┼─────────┼─────────
//   │   3.500 │   4.500 │       3 │     128 │     205 │ (x-4)**5 * log(x)
//   ┼─────────┼─────────┼─────────┼─────────┼─────────┼─────────
//   │   2.000 │   3.000 │      54 │     148 │     122 │ (sin(x) - x/4)**3
//   ┼─────────┼─────────┼─────────┼─────────┼─────────┼─────────
//   │   1.000 │   2.000 │      13 │      41 │      30 │ {x += 1.11111; return (81 - x*(108 - x*(54 - x*(12-x)))) * sign(x-3);}
//   ┼─────────┼─────────┼─────────┼─────────┼─────────┼─────────
//   │   7.000 │   8.000 │      52 │     147 │     118 │ sin( (x-7.143)**3 )
//   ┼─────────┼─────────┼─────────┼─────────┼─────────┼─────────
//   │   2.500 │   3.500 │       3 │      28 │      43 │ exp( (x-3)**5 ) - 1
//   ┼─────────┼─────────┼─────────┼─────────┼─────────┼─────────
//   │   4.000 │   5.000 │      53 │      14 │      18 │ exp( (x-3)**5 ) - exp(x-1)
//   ┼─────────┼─────────┼─────────┼─────────┼─────────┼─────────


// REFERENCES
// ----------
// .. [1] "Improved Algorithms Of Illinois-Type For The Numerical Solution Of Nonlinear Equations"
//         J. A. Ford
// .. [2] "A family of regula falsi root-finding methods"
//         Sérgio Galdino


export function generic_test_root1d_bracketed( root1d )
{
  const MAX_ITER = 1e6;

  const abs = x => Math. abs(x),
        sin = x => Math. sin(x),
        cos = x => Math. cos(x),
        exp = x => Math. exp(x),
        log = x => Math. log(x),
        sqrt= x => Math.sqrt(x),
        sign= x => Math.sign(x);

  const benchmark = {};

  function test_with( x0, ranges, test_fn )
  {
    const results = benchmark[`${test_fn}`] = [];

    forEachItemIn(ranges).it(`solves (${test_fn})`, ([xMin,xMax]) => {
      let n=-1;
      const f = x => {
        if(++n > MAX_ITER) throw new Error('Assertion failed.');
        if( !(x <= xMax) ) throw new Error('Assertion failed.');
        if( !(x >= xMin) ) throw new Error('Assertion failed.');
        return test_fn(x);
      };
      const  f_x0 = f(x0);
      expect(f_x0).toBeAllCloseTo(0, {atol: 2e-13});

      let x = root1d(f, xMin, xMax); results.push([xMin, xMax, n]);

      expect( f(x ) ).toBeAllCloseTo(0, {atol: 2e-13});
      expect( abs(f(x)) ).toBeLessThanOrEqual( abs(f_x0) )

          x = root1d(f, xMax, xMin);

      expect( f(x ) ).toBeAllCloseTo(0, {atol: 2e-13});
      expect( abs(f(x)) ).toBeLessThanOrEqual( abs(f_x0) )
    })
  }

  describe(`${root1d.name} [generic tests]`, () => {
    beforeEach( () => {
      jasmine.addMatchers(CUSTOM_MATCHERS)
    })

    // FORD's TEST FUNCTIONS [1]
    // -----------------------
    // 1.
    test_with(0.904788217873018853474021360, [[   0.0000,   1.50 ],
                                              [  -1.0000,   3.00 ],
                                              [  -1.5000,   6.00 ]], x => 4*cos(x) - exp(x));
    // 2.
    test_with(5.0                          , [[   4.0000,   6.50 ],
                                              [   2.0000,   8.00 ],
                                              [   0.0000,  15.00 ],
                                              [  -5.0000,  25.00 ]], x => { let s=0; for( let i=0; i++ < 10; ) s += exp(i*x/10) - exp(i/2); return s; });
    // 3.
    test_with(0.034657359020853851362      , [[   0.0000,   1.00 ],
                                              [  -0.1000,   1.50 ],
                                              [  -0.5000,   2.00 ],
                                              [  -1.0000,   4.00 ]], x => 2*x*exp(-20) + 1 - 2*exp(-20*x));
    // 4.
    test_with(0.04                         , [[   0.0350,   0.05 ],
                                              [   0.0300,   0.09 ],
                                              [   0.0250,   0.50 ],
                                              [   0.0200,   1.00 ]], x => exp(1/x - 25) - 1);
    // 5.
    test_with(1.0                          , [[   0.9000,   1.10 ],
                                              [   0.5000,   1.50 ],
                                              [  -5.0000,   5.00 ],
                                              [  -5.0000,  10.00 ]], x => { let p=1e-8*(x-1); for( let i=0; i++ < 10; ) p *= (x*(x+1)+i); return p; });
    // 6.
    test_with(0.1                          , [[   0.0950,   1.00 ],
                                              [   0.0750,   0.15 ],
                                              [   0.0800,   0.50 ],
                                              [   0.0500,   0.20 ]], x => 1e10 * (x**(1/x)) - 1);
    // 7.
    test_with(1.0                          , [[   0.9000,   1.05 ],
                                              [   0.7000,   1.20 ],
                                              [   0.0000,   2.50 ],
                                              [  -0.5000,   5.00 ]], x => x**20 - 1);
    // 8.
    test_with(551.77382493032659963        , [[ 550.0000, 560.00 ],
                                              [ 525.0000, 590.00 ],
                                              [ 400.0000, 600.00 ],
                                              [ 350.0000, 850.00 ]], x => exp(21e3/x) / (1.11e11*x*x)  -  1);
    // 9.
    test_with(0.0095556044375379333908     , [[   0.0050,   0.02 ],
                                              [   0.0010,   0.05 ],
                                              [   0.0001,   0.10 ],
                                              [   0.0010, 100.00 ]], x => 1/x + Math.log(x) - 100);
    // 10.
    test_with(1.0                          , [[   0.0000,   2.00 ],
                                              [  -4.0000,   2.00 ],
                                              [ -10.0000,   3.00 ],
                                              [   0.5000,   3.50 ]], x => exp(Math.exp(x)) - exp(Math.E) );
    // 11.
    test_with(0.01 / Math.asin(0.01)       , [[   0.5000,   2.00 ],
                                              [   0.2000,   6.00 ],
                                              [   0.0500,  20.00 ],
                                              [   0.0040, 200.00 ]], x => sin(0.01/x) - 0.01);

    // GALDINO's TEST FUNCTIONS [2]
    // g1
    test_with(1.0                           , [[ 0.5, 1.5]], x => x*x*x - 1);
    // g2
    test_with(0.39942229171096819451        , [[ 0.1, 1.0]], x => x*x*(x*x/3 + sqrt(2)*sin(x))  -  sqrt(3)/18 );
    // g3
    test_with( (1/11)**(1/11)               , [[ 0.1, 1.0]], x => 11 * (x**11) - 1);
    // g4
    test_with(-1.0                          , [[-1.8, 0.0]], x => x*x*x + 1);
    // g5
    test_with(2.279018786166593579491443    , [[ 2.0, 3.0]], x => x*x*x - 3*x - 5);
    // g6
    test_with(0.13825715505682408           , [[ 0.0, 1.0]], x => 2*x*exp(- 5) + 1 - 2*exp(- 5*x) );
    // g7
    test_with(0.069314088687023473303       , [[ 0.0, 1.0]], x => 2*x*exp(-10) + 1 - 2*exp(-10*x) );
    // g8
    test_with(0.034657359020853851362       , [[ 0.0, 1.0]], x => 2*x*exp(-20) + 1 - 2*exp(-20*x) );
    // g9
    test_with( ( 5 - sqrt( 17  )) / 8       , [[ 0.0, 1.0]], x => (1 + (1- 5)**2)*x*x  -  (1- 5*x)**2 );
    // g10
    test_with( ( 5 - sqrt( 41/2)) / 9       , [[ 0.0, 1.0]], x => (1 + (1-10)**2)*x*x  -  (1-10*x)**2 );
    // g11
    test_with( (10 - sqrt(181/2)) / 19      , [[ 0.0, 1.0]], x => (1 + (1-20)**2)*x*x  -  (1-20*x)**2 );
    // g12
    test_with(0.34595481584824201796        , [[ 0.0, 1.0]], x => x*x - (1-x)** 5 );
    // g13
    test_with(0.24512233375330723995        , [[ 0.0, 1.0]], x => x*x - (1-x)**10 );
    // g14
    test_with(0.16492095727644095239        , [[ 0.0, 1.0]], x => x*x - (1-x)**20 );
    // g15
    test_with(0.003617108178904063540768351 , [[ 0.0, 1.0]], x => (1 + (1 - 5)**4)*x  -  (1 - 5*x)**4 );
    // g16
    test_with(0.0001514713347838913936418667, [[ 0.0, 1.0]], x => (1 + (1 -10)**4)*x  -  (1 -10*x)**4 );
    // g17
    test_with(7.668595122185336697465609e-6 , [[ 0.0, 1.0]], x => (1 + (1 -20)**4)*x  -  (1 -20*x)**4 );
    // g18
    test_with(0.51615351875793356643        , [[ 0.0, 1.0]], x => exp(- 5*x)*(x-1) + x** 5 );
    // g19
    test_with(0.53952222690841584317        , [[ 0.0, 1.0]], x => exp(-10*x)*(x-1) + x**10 );
    // g20
    test_with(0.55270466667848778724        , [[ 0.0, 1.0]], x => exp(-20*x)*(x-1) + x**20 );
    // g21
    test_with(0.40999201798913715           , [[ 0.0, 1.0]], x => x*x + sin(x / 5) - 1/4 );
    // g22
    test_with(0.45250914557764122546        , [[ 0.0, 1.0]], x => x*x + sin(x /10) - 1/4 );
    // g23
    test_with(0.47562684859606241312        , [[ 0.0, 1.0]], x => x*x + sin(x /20) - 1/4 );

    // f1
    test_with(3.0                           , [[ 2.5, 3.5]], x => (x+2) * (x+1) * (x-3)**3 );
    // f2
    test_with(4.0                           , [[ 3.5, 4.5]], x => (x-4)**5 * log(x) );
    // f3
    test_with(2.4745767873698290126         , [[ 2.0, 3.0]], x => (sin(x) - x/4)**3 );
    // f4
    test_with(3 - 1.11111                   , [[ 1.0, 2.0]], x => {x += 1.11111; return (81 - x*(108 - x*(54 - x*(12-x)))) * sign(x-3);} );
    // f5
    test_with(7.143                         , [[ 7.0, 8.0]], x => sin( (x-7.143)**3 ) );
    // f6
    test_with(3.0                           , [[ 2.5, 3.5]], x => exp( (x-3)**5 ) - 1 );
    // f7
    test_with(4.2671683045421243173         , [[ 4.0, 5.0]], x => exp( (x-3)**5 ) - exp(x-1) );


    forEachItemIn(
      linspace(0,64, 773*1337)
    ).it('computes square roots correctly', xx => {
      let n=0;
      const xMin = 0,
            xMax = Math.max(1,xx),
            f = x => {
              if(++n > MAX_ITER) throw new Error('Assertion failed.');
              if( !(x <= xMax) ) throw new Error('Assertion failed.');
              if( !(x >= xMin) ) throw new Error('Assertion failed.');
              return x*x - xx;
            },
            x0 = Math.sqrt(xx),
          f_x0 = f(x0);

      let x = root1d( f, xMin, xMax );
      expect( abs(f(x)) ).toBeLessThanOrEqual( abs(f_x0) );
      expect( f(x) ).toBeAllCloseTo(0, {atol: 1e-13});

          x = root1d( f, xMax, xMin );
      expect( abs(f(x)) ).toBeLessThanOrEqual( abs(f_x0) );
      expect( f(x) ).toBeAllCloseTo(0, {atol: 1e-13});
    })

    forEachItemIn(
      linspace(0,64, 773*1337)
    ).it('computes cube roots correctly', xxx => {
      let n=0;
      const xMin = 0,
            xMax = Math.max(1,xxx),
            f = x => {
              if(++n > MAX_ITER) throw new Error('Assertion failed.');
              if( !(x <= xMax) ) throw new Error('Assertion failed.');
              if( !(x >= xMin) ) throw new Error('Assertion failed.');
              return x*x*x - xxx;
            },
            x0 = xxx**(1/3),
          f_x0 = f(x0);;

      let x = root1d( f, xMin, xMax );
      expect( abs(f(x)) ).toBeLessThanOrEqual( abs(f_x0) );
      expect( f(x) ).toBeAllCloseTo(0, {atol: 1e-13});

          x = root1d( f, xMax, xMin );
      expect( abs(f(x)) ).toBeLessThanOrEqual( abs(f_x0) );
      expect( f(x) ).toBeAllCloseTo(0, {atol: 1e-13});
    })

    // // LOG BENCHMARK
    // afterAll(() => {
    //   let str = '\n│  x_min  │  x_max  │ ' + root1d.name.slice('root1d_'.length).padEnd(8) + '│ test_fn \n';
    //   const hline = [...str].map(c => c==='│' ? '┼' : c==='\n' ? '' : '─').join('') + '\n';
    //       str    += [...str].map(c => c==='│' ? '┿' : c==='\n' ? '' : '━').join('') + '\n';

    //   for( const [k,v] of Object.entries(benchmark) )
    //   {
    //     let i=0;
    //     for( let [x,X,n] of v )
    //     {
    //       str += '│' + x.toFixed(3).padStart(8) + ' ';
    //       str += '│' + X.toFixed(3).padStart(8) + ' ';
    //       str += '│' + n.toString().padStart(8) + ' │';
    //       if( i++ === v.length-1 >>> 1 )
    //         str += ' ' + k.slice('x => '.length);
    //       str += '\n'
    //     }
    //     str += hline;
    //   }

    //   console.log(str);
    // })
  });
}
