<!DOCTYPE html><html><head><meta charset="utf-8"><title>ND.JS v0.8.13 Documentation</title></head><body style="font-family: monospace;"><h1>ND.JS v0.8.13 Documentation</h1><ul><li><a href="#nd.help">nd.help</a></li><li><a href="#nd.help_str">nd.help_str</a></li><li><a href="#nd.math">nd.math</a></li><li><a href="#nd.dt">nd.dt</a></li><li><a href="#nd.opt">nd.opt</a></li><li><a href="#nd.la">nd.la</a></li><li><a href="#nd.io">nd.io</a></li><li><a href="#nd.array">nd.array</a></li><li><a href="#nd.asarray">nd.asarray</a></li><li><a href="#nd.NDArray">nd.NDArray</a></li><li><a href="#nd.rand_normal">nd.rand_normal</a></li><li><a href="#nd.tabulate">nd.tabulate</a></li><li><a href="#nd.zip_elems">nd.zip_elems</a></li><li><a href="#nd.concat">nd.concat</a></li><li><a href="#nd.stack">nd.stack</a></li><li><a href="#nd.la.bidiag_decomp">nd.la.bidiag_decomp</a></li><li><a href="#nd.la.cholesky_decomp">nd.la.cholesky_decomp</a></li><li><a href="#nd.la.cholesky_solve">nd.la.cholesky_solve</a></li><li><a href="#nd.la.diag_mat">nd.la.diag_mat</a></li><li><a href="#nd.la.diag">nd.la.diag</a></li><li><a href="#nd.la.eigen">nd.la.eigen</a></li><li><a href="#nd.la.eigenvals">nd.la.eigenvals</a></li><li><a href="#nd.la.eigen_balance_pre">nd.la.eigen_balance_pre</a></li><li><a href="#nd.la.eigen_balance_post">nd.la.eigen_balance_post</a></li><li><a href="#nd.la.eye">nd.la.eye</a></li><li><a href="#nd.la.hessenberg_decomp">nd.la.hessenberg_decomp</a></li><li><a href="#nd.la.lstsq">nd.la.lstsq</a></li><li><a href="#nd.la.lu_decomp">nd.la.lu_decomp</a></li><li><a href="#nd.la.lu_solve">nd.la.lu_solve</a></li><li><a href="#nd.la.matmul2">nd.la.matmul2</a></li><li><a href="#nd.la.matmul">nd.la.matmul</a></li><li><a href="#nd.la.norm">nd.la.norm</a></li><li><a href="#nd.la.permute_rows">nd.la.permute_rows</a></li><li><a href="#nd.la.permute_cols">nd.la.permute_cols</a></li><li><a href="#nd.la.unpermute_rows">nd.la.unpermute_rows</a></li><li><a href="#nd.la.unpermute_cols">nd.la.unpermute_cols</a></li><li><a href="#nd.la.qr_decomp_full">nd.la.qr_decomp_full</a></li><li><a href="#nd.la.qr_decomp">nd.la.qr_decomp</a></li><li><a href="#nd.la.qr_lstsq">nd.la.qr_lstsq</a></li><li><a href="#nd.la.rank">nd.la.rank</a></li><li><a href="#nd.la.rrqr_decomp">nd.la.rrqr_decomp</a></li><li><a href="#nd.la.rrqr_decomp_full">nd.la.rrqr_decomp_full</a></li><li><a href="#nd.la.rrqr_rank">nd.la.rrqr_rank</a></li><li><a href="#nd.la.rrqr_lstsq">nd.la.rrqr_lstsq</a></li><li><a href="#nd.la.rrqr_solve">nd.la.rrqr_solve</a></li><li><a href="#nd.la.schur_eigenvals">nd.la.schur_eigenvals</a></li><li><a href="#nd.la.schur_eigen">nd.la.schur_eigen</a></li><li><a href="#nd.la.schur_decomp">nd.la.schur_decomp</a></li><li><a href="#nd.la.SingularMatrixSolveError">nd.la.SingularMatrixSolveError</a></li><li><a href="#nd.la.solve">nd.la.solve</a></li><li><a href="#nd.la.svd_decomp">nd.la.svd_decomp</a></li><li><a href="#nd.la.svd_rank">nd.la.svd_rank</a></li><li><a href="#nd.la.svd_solve">nd.la.svd_solve</a></li><li><a href="#nd.la.svd_lstsq">nd.la.svd_lstsq</a></li><li><a href="#nd.la.svd_jac_2sided">nd.la.svd_jac_2sided</a></li><li><a href="#nd.la.svd_jac_2sided_blocked">nd.la.svd_jac_2sided_blocked</a></li><li><a href="#nd.la.svd_jac_classic">nd.la.svd_jac_classic</a></li><li><a href="#nd.la.tril">nd.la.tril</a></li><li><a href="#nd.la.triu">nd.la.triu</a></li><li><a href="#nd.la.tril_solve">nd.la.tril_solve</a></li><li><a href="#nd.la.triu_solve">nd.la.triu_solve</a></li><li><a href="#nd.opt.line_search">nd.opt.line_search</a></li><li><a href="#nd.opt.min_lbfgs_gen">nd.opt.min_lbfgs_gen</a></li><li><a href="#nd.opt.strong_wolfe">nd.opt.strong_wolfe</a></li><li><a href="#nd.opt.num_grad">nd.opt.num_grad</a></li><li><a href="#nd.opt.root1d_bisect">nd.opt.root1d_bisect</a></li><li><a href="#nd.opt.line_search.strong_wolfe">nd.opt.line_search.strong_wolfe</a></li><li><a href="#nd.io.IS_LITTLE_ENDIAN">nd.io.IS_LITTLE_ENDIAN</a></li><li><a href="#nd.io.WHITESPACES">nd.io.WHITESPACES</a></li><li><a href="#nd.io.b64_decode">nd.io.b64_decode</a></li><li><a href="#nd.io.b64_decode_gen">nd.io.b64_decode_gen</a></li><li><a href="#nd.io.b64_encode">nd.io.b64_encode</a></li><li><a href="#nd.io.b64_encode_gen">nd.io.b64_encode_gen</a></li><li><a href="#nd.io.istr_parse">nd.io.istr_parse</a></li><li><a href="#nd.io.istr_stringify">nd.io.istr_stringify</a></li><li><a href="#nd.io.istr_stringify_gen">nd.io.istr_stringify_gen</a></li><li><a href="#nd.io.npy_serialize">nd.io.npy_serialize</a></li><li><a href="#nd.io.npy_serialize_gen">nd.io.npy_serialize_gen</a></li><li><a href="#nd.io.npy_deserialize">nd.io.npy_deserialize</a></li><li><a href="#nd.dt.ARRAY_TYPES">nd.dt.ARRAY_TYPES</a></li><li><a href="#nd.dt.eps">nd.dt.eps</a></li><li><a href="#nd.dt.cast_scalar">nd.dt.cast_scalar</a></li><li><a href="#nd.dt._check_dtype">nd.dt._check_dtype</a></li><li><a href="#nd.dt.dtypeof">nd.dt.dtypeof</a></li><li><a href="#nd.dt.super_dtype">nd.dt.super_dtype</a></li><li><a href="#nd.dt.is_subdtype">nd.dt.is_subdtype</a></li><li><a href="#nd.dt.Complex">nd.dt.Complex</a></li><li><a href="#nd.dt.Complex128Array">nd.dt.Complex128Array</a></li><li><a href="#nd.NDArray.length_STATIC">nd.NDArray.length [STATIC]</a></li><li><a href="#nd.NDArray.name_STATIC">nd.NDArray.name [STATIC]</a></li><li><a href="#nd.NDArray.prototype_STATIC">nd.NDArray.prototype [STATIC]</a></li><li><a href="#nd.NDArray.constructor">nd.NDArray.constructor</a></li><li><a href="#nd.NDArray.set">nd.NDArray.set</a></li><li><a href="#nd.NDArray.modify">nd.NDArray.modify</a></li><li><a href="#nd.NDArray._flat_idx">nd.NDArray._flat_idx</a></li><li><a href="#nd.NDArray.toString">nd.NDArray.toString</a></li><li><a href="#nd.NDArray.toNestedArray">nd.NDArray.toNestedArray</a></li><li><a href="#nd.NDArray.forEach">nd.NDArray.forEach</a></li><li><a href="#nd.NDArray.elems">nd.NDArray.elems</a></li><li><a href="#nd.NDArray.forElems">nd.NDArray.forElems</a></li><li><a href="#nd.NDArray.valueOf">nd.NDArray.valueOf</a></li><li><a href="#nd.NDArray.mapElems">nd.NDArray.mapElems</a></li><li><a href="#nd.NDArray.transpose">nd.NDArray.transpose</a></li><li><a href="#nd.NDArray.reshape">nd.NDArray.reshape</a></li><li><a href="#nd.NDArray.reduceElems">nd.NDArray.reduceElems</a></li><li><a href="#nd.NDArray.sliceElems">nd.NDArray.sliceElems</a></li><li><a href="#nd.dt.Complex.length_STATIC">nd.dt.Complex.length [STATIC]</a></li><li><a href="#nd.dt.Complex.name_STATIC">nd.dt.Complex.name [STATIC]</a></li><li><a href="#nd.dt.Complex.prototype_STATIC">nd.dt.Complex.prototype [STATIC]</a></li><li><a href="#nd.dt.Complex.constructor">nd.dt.Complex.constructor</a></li><li><a href="#nd.dt.Complex.add">nd.dt.Complex.add</a></li><li><a href="#nd.dt.Complex.sub">nd.dt.Complex.sub</a></li><li><a href="#nd.dt.Complex.mul">nd.dt.Complex.mul</a></li><li><a href="#nd.dt.Complex.div">nd.dt.Complex.div</a></li><li><a href="#nd.dt.Complex.equals">nd.dt.Complex.equals</a></li><li><a href="#nd.dt.Complex.abs">nd.dt.Complex.abs</a></li><li><a href="#nd.dt.Complex.arg">nd.dt.Complex.arg</a></li><li><a href="#nd.dt.Complex.conj">nd.dt.Complex.conj</a></li><li><a href="#nd.dt.Complex.toFixed">nd.dt.Complex.toFixed</a></li><li><a href="#nd.dt.Complex.sqrt">nd.dt.Complex.sqrt</a></li><li><a href="#nd.dt.Complex.toString">nd.dt.Complex.toString</a></li><li><a href="#nd.dt.Complex.valueOf">nd.dt.Complex.valueOf</a></li></ul><h2 id="nd.help">nd.help</h2><pre>Outputs a documentation string for the given method ND.JS method to the console. This method
is intended to be used in interactive mode to explore and learn the ND.JS API.

This method is only available in the non-minfied version of ND.JS.

Parameters
----------
fun: Function
  The function or package ND.JS API method for which the documentation is to be retrieved.

Examples
--------
&gt;&gt;&gt; nd.help(nd.la)
  The Linear Algebra subpackage of ND.JS. Contains methods for the handling and decomposition
  of matrices as well as solvers for linear equations and linear least square systems.

  As convention the last two axes of an `NDArray` are considered as the matrix dimensions.
  Higher dimensional arrays are considered "arrays of matrices" and the broadcasting rules
  apply for the leading dimenions, i.e. for all dimensions of the shape except the last two.
</pre><h2 id="nd.help_str">nd.help_str</h2><pre>Returns a documentation string for the given method ND.JS method to the console. This method
is used by `create_doc_jsdom()` to create the documentation and by `nd.help()` to
print help to the console.

This method is only available in the non-minfied version of ND.JS.

Parameters
----------
fun: Function
  The function or package ND.JS API method for which the documentation is to be retrieved.

Returns
-------
help: String
  A documentation String for the given method or package.

Examples
--------
&gt;&gt;&gt; console.log( nd.help(nd.la) )
  "The Linear Algebra subpackage of ND.JS. Contains methods for the handling and decomposition
   of matrices as well as solvers for linear equations and linear least square systems.

   As convention the last two axes of an `NDArray` are considered as the matrix dimensions.
   Higher dimensional arrays are considered "arrays of matrices" and the broadcasting rules
   apply for the leading dimenions, i.e. for all dimensions of the shape except the last two."
</pre><h2 id="nd.math">nd.math</h2><pre>No documentation available.</pre><h2 id="nd.dt">nd.dt</h2><pre>No documentation available.</pre><h2 id="nd.opt">nd.opt</h2><pre>No documentation available.</pre><h2 id="nd.la">nd.la</h2><pre>The Linear Algebra subpackage of ND.JS. Contains methods for the handling and decomposition
of matrices as well as solvers for linear equations and linear least square systems.

As convention the last two axes of an `NDArray` are considered as the matrix dimensions.
Higher dimensional arrays are considered "arrays of matrices" and the broadcasting rules
apply for the leading dimenions, i.e. for all dimensions of the shape except the last two.
</pre><h2 id="nd.io">nd.io</h2><pre>No documentation available.</pre><h2 id="nd.array">nd.array</h2><pre>Tries to heuristically create an NDArray from the input. This
method is usually used to create NDArrays nested arrays, which
allows for a creation of NDArray which is well readable by
humans.

  * If the input is an object containing a 'shape' and 'data'
    property, a new NDArray is created using said shape and data
    directly (creating a protection copy of data).
  * If the input is a (possibly nested) JavaScript array-like, it
    is converted to an NDArray, copying the array data in the
    process. The nesting defines the shape of the resulting
    NDArray. 
  * Otherwise the data is interpreted as a scalar value and
    is put into an NDArray of shape [].

Parameters
----------
dtype: String
  [Optional] The dtype of the returned NDArray.
content: { length: int[], data: dtype[] } or dtype or dtype[] or dtype[][] or ...
  The content of the returned NDArray.

Returns
-------
ndarray: NDArray
  An NDArray representation of the content.

Examples
--------
&gt;&gt;&gt; let content = { shape: [2,3], data: [1,2,3,4,5,6] }
&gt;&gt;&gt; let a = nd.array(content)
&gt;&gt;&gt; console.log( a.toString() )
  [[1,2,3],
   [4,5,6]]
&gt;&gt;&gt; content.data[3] = 7
&gt;&gt;&gt; console.log( a.toString() )
  [[1,2,3],
   [7,5,6]]


&gt;&gt;&gt; let content = { shape: [2,3], data: [1,2,3,4,5,6] }
&gt;&gt;&gt; let a = nd.array('int32',content)
&gt;&gt;&gt; console.log( a.toString() )
  [[1,2,3],
   [4,5,6]]
&gt;&gt;&gt; content.data[3] = 7
&gt;&gt;&gt; console.log( a.toString() )
  [[1,2,3],
   [4,5,6]]


&gt;&gt;&gt; let a = nd.array([
...   [1,2,3,4],
...   [5,6,7,8]
... ])
&gt;&gt;&gt; console.log( a.toString() )
  [[1,2,3,4],
   [5,6,7,8]]


&gt;&gt;&gt; console.log( nd.array(12) )
  { [NDArray: self] shape: [], data: Int32Array[12] }
</pre><h2 id="nd.asarray">nd.asarray</h2><pre>Similar to `nd.array(content)` except that input is not copied if
it already is an `NDArray`.

Parameters
----------
content: { length: int[], data: dtype[] } or dtype or dtype[] or dtype[][] or ...
  The content of the returned NDArray.

Returns
-------
ndarray: NDArray
  `ndarray = content instanceof NDArray ? content : nd.array(content);`
</pre><h2 id="nd.NDArray">nd.NDArray</h2><pre>An n-dimensional, axis-aligned grid of entries, very similar
to NumPy ndarrays in Python.

Attributes
----------
shape: int[]
  The shape of the NDArray.
data : dtype[]
  The flat data array backing this NDArray. May be either
  a standard JavaScript Array, or one of JavaScripts primitive
  array types. See nd.dtypes for a list of supported data types.
ndim: int
  The number of dimensions in this NDArray, i.e. the number of
  indices used to address the entries. Equivalent to shape.length.
  
dtype: String
  The data type of this NDArray. Specifies which type of values
  may be stored in the NDArray. See nd.dtypes for the available
  data types and their respective (primitive) array types.
</pre><h2 id="nd.rand_normal">nd.rand_normal</h2><pre>No documentation available.</pre><h2 id="nd.tabulate">nd.tabulate</h2><pre>Creates a new NDArray of the given shape, calling a function for
each entry index and using the returned value as entry value of
the new NDArray.

Parameters
----------
shape: int[]
  The shape of the new NDArray.
dtype: String
  [OPTIONAL] The data type of the newly created NDArray.
idx2val: (...int) =&gt; dtype
  The function returning the entry value for a given entry index as input.

Returns
-------
ndarray: NDArray
  The newly tabulated NDArray, where:
  ndarray(i0,i1,...,i[n]) = idx2val(i0,i1,...i[n])

Examples
--------
&gt;&gt;&gt; let a = nd.tabulate([3,2], (i,j) =&gt; 10*(i+1) + (j+1) )
&gt;&gt;&gt; console.log( a.toString() )
  [[11,12],
   [21,22],
   [31,32]]
</pre><h2 id="nd.zip_elems">nd.zip_elems</h2><pre>Creates a new NDArray from one or more NDArrays, using a function to
merge the values of the NDArray(s) to the values of the new NDArray.

This can be used to perform unary (sin, cos, exp, ...) and binary
(+, -, *, ...) operations.

This method supports NumPy-style broadcasting of the NDArray arguments.

Parameters
----------
ndarray: NDArray or NDArray[]
  The NDArray or list of NDArrays from which the new NDArray is built.
dtype: String
  [OPTIONAL] The data type of the new NDArray.
mapper: (...values, ...indices) =&gt; dtype
  A function used to determine the entry values of the new NDArray from
  the entry values of the old NDArray(s). May be omitted if only a single
  NDArray is given by ndarray, in which case the entry values are copied.

Returns
-------
ndarray: NDArray
  The newly created NDArray, where:
  ndarray(i0,i1,...,i[n]) = mapper(ndarray[0](i0,i1,...,i[n]), ndarray[1](i0,i1,...,i[n]), ..., ndarray[m](i0,i1,...,i[n]), i0,i1,...,i[n]).

Examples
--------
&gt;&gt;&gt; let a = nd.array([1,2,3,4])
&gt;&gt;&gt; let b = nd.zip_elems(a, x =&gt; x*x)
&gt;&gt;&gt; console.log( b.toString() )
  [1, 4, 9, 16]


&gt;&gt;&gt; let c = nd.array([[1],[2]])
&gt;&gt;&gt; let d = nd.array([1,2,3,4])
&gt;&gt;&gt; let e = zip_elems([c,d], (x,y) =&gt; 10*x+y )
&gt;&gt;&gt; console.log( e.toString() )
  [[11,12,13,14],
   [21,22,23,24]]
</pre><h2 id="nd.concat">nd.concat</h2><pre>Arranges a list of NDArrays into a new NDArray. The NDArrays are concatenated
along an existing specified axis. Aside from said axis, the shape of all NDArrays
must be the same.

Parameters
----------
axis: int
  [OPTIONAL] The axis along which the NDArrays are concatenated. Default value: 0.
dtype: String
  [OPTIONAL] The type of the concatenated NDArray. Should be a super-dtype of all NDArrays'
  dtypes.
ndarrays: NDArray[]
  The NDArrays that are to be concatenated. All NDArrays must have the same shape.

Returns
-------
concatenated: NDArray


Examples
--------
&gt;&gt;&gt; let a = nd.array([[1,2],[3,4]])
&gt;&gt;&gt; let b = nd.array([[5,6],[7,8]])
&gt;&gt;&gt; console.log( nd.concat([a,b]).toString() )
  [[1,2],
   [3,4],
   [5,6],
   [7,8]]
   
&gt;&gt;&gt; console.log( nd.concat(1,[a,b]).toString() )
  [[1,2,5,6],
   [3,4,7,8]]
</pre><h2 id="nd.stack">nd.stack</h2><pre>Arranges a list of NDArrays into a new NDArray. The NDArrays are stacked
along a newly axis, inserted at the specified index. All stacked NDArrays
must have the same shape.

Parameters
----------
axis: int
  [OPTIONAL] The index at which the new index is to be inserted. Default value: 0.
dtype: String
  [OPTIONAL] The type of the stacked NDArray. Should be a super-dtype of all NDArrays'
  dtypes.
ndarrays: NDArray[]
  The NDArrays that are to be stacked. All NDArrays must have the same shape.

Returns
-------
stacked: NDArray

Examples
--------
&gt;&gt;&gt; let a = nd.array([1,2,3])
&gt;&gt;&gt; let b = nd.array([4,5,6])
&gt;&gt;&gt; console.log( nd.stack([a,b]).toString )
  [[1,2,3],
   [4,5,6]]

&gt;&gt;&gt; console.log( nd.stack(1,'float64',[a,b]).toString )
  [[1.0, 4.0],
   [2.0, 5.0],
   [3.0, 6.0]]
</pre><h2 id="nd.la.bidiag_decomp">nd.la.bidiag_decomp</h2><pre>Computes the Upper Bidiagonal Decomposition of a matrix. Bidiagonal
Decomposition is a common preprocessing step for the Singular Value
Decomposition.

Parameters
----------
A: NDArray[...,N,M]
  The matrix for which the Upper Bidiagonal Decomposition is
  computed.

Returns
-------
U: NDArray[..., N, min(N,M)]
  An orthognal rectangular matrix.
B: NDArray[..., min(N,M), N &gt;= M ? M : N+1 ]
  An upper bidiagonal rectangular matrix.
V: NDArray[..., N &gt;= M ? M : N+1, M]
  An orthogonal rectangular matrix. Such that `A = U @ B @ V @`
</pre><h2 id="nd.la.cholesky_decomp">nd.la.cholesky_decomp</h2><pre>Computes the Cholesky Decomposition of an `NDArray` of symmetric, positive
definite (square) matrices. The implementation assume the matrices to be symmetric
and only looks at the lower triangular values. The last two axes of the `NDArray`
are considered to be the matrix dimensions.

Parameters
----------
S: NDArray[...,N,N]
  An `NDArray` of symmetric, positive definite (square) matrices. In other words
  S is symmetric and has only positive eigenvalues. 

Returns
-------
L: NDArray[...,N,N]
  A lower triangular matrix, such that `S = L @ L.T`.

Examples
--------
&gt;&gt;&gt; const S = [
...   [ 25, -50],
...   [-50, 101]
... ];
&gt;&gt;&gt; const L = nd.la.cholesky_decomp(S);
&gt;&gt;&gt; console.log( nd.la.matmul2(L,L.T).toString() );
  [[ 25, -50],
   [-50, 101]]
</pre><h2 id="nd.la.cholesky_solve">nd.la.cholesky_solve</h2><pre>Given a cholesky decomposition and the right hand side of a linear equation system,
this method computes the result of said system.

Parameters
----------
L: NDArray[...,N,N]
  An array of lower triangular (square) matrices. L is assumed to be lower triangular
  without looking at the upper triangular values.
y: NDArray[...,N,M]
  The right hand side of the linear equations system.

Returns
-------
x: NDArray[...,N,M]
  Such that `L @ L.T @ x == y`.

Examples
--------
&gt;&gt;&gt; const S = [
...   [ 25, -50],
...   [-50, 101]
... ];
&gt;&gt;&gt; const y = [
...   [[1],
...    [2]],
...   [[3],
...    [4]]
... ];
&gt;&gt;&gt; const L = nd.la.cholesky_decomp(S);
&gt;&gt;&gt; const x = nd.la.cholesky_solve(L,y);
&gt;&gt;&gt; console.log( nd.la.matmul2(S,x) );
 [[[1.0],
   [2.0]],
  [[3.0],
   [4.0]]]
</pre><h2 id="nd.la.diag_mat">nd.la.diag_mat</h2><pre>Creates a (main) diagonal matrix with the given diagonal values.

Parameters
----------
diag: NDArray[...,N]
  The diagonal values.

Returns
-------
D: NDArray[...,N,N]
  Such that `D(i,j) == i==j ? diag(i) : 0`.

Examples
--------
&gt;&gt;&gt; const D = nd.la.diag_mat([[1,2,3],[4,5,6]]);
&gt;&gt;&gt; console.log( D.toString() );
  [[[ 1, 0, 0 ],
    [ 0, 2, 0 ],
    [ 0, 0, 3 ]],
   [[ 4, 0, 0 ],
    [ 0, 5, 0 ],
    [ 0, 0, 6 ]]]
</pre><h2 id="nd.la.diag">nd.la.diag</h2><pre>No documentation available.</pre><h2 id="nd.la.eigen">nd.la.eigen</h2><pre>Returns the eigenpairs of a real square matrix.

Parameters
----------
A: NDArray[...,N,N]
  The non-symmetric real squre matrix for which the eigenvalues are computed.

Returns
-------
Λ: NDArray[...,N]
  A matrix containing all eigenvalues.
V: NDArray[...,N,N]
  A matrix containing the eigenvectors corresponding to Λ as columns, i.e.:
  `Λ[i]*V[j,i] == (A @ V)[j,i]`.
  The columns are normalized using the 2-norm. 
</pre><h2 id="nd.la.eigenvals">nd.la.eigenvals</h2><pre>No documentation available.</pre><h2 id="nd.la.eigen_balance_pre">nd.la.eigen_balance_pre</h2><pre>No documentation available.</pre><h2 id="nd.la.eigen_balance_post">nd.la.eigen_balance_post</h2><pre>No documentation available.</pre><h2 id="nd.la.eye">nd.la.eye</h2><pre>Returns an NDArray of identity matrices, where the last two axes are the matrix dimensions.

Parameters
----------
shape: ...int
  The shape of the resulting array. If only one value N is given, an N*N identity
  matrix is returned.

Returns
-------
I: NDArray
  The array of identity matrices, where the last two axes are the matrix dimensions.

Examples
--------
&gt;&gt;&gt; const I = nd.la.eye(2);
&gt;&gt;&gt; console.log( I.toString() );
  [[1,0],
   [0,1]]

&gt;&gt;&gt; const J = nd.la.eye(2,3,4);
&gt;&gt;&gt; console.log( J.toString() );
  [[[ 1, 0, 0, 0],
    [ 0, 1, 0, 0],
    [ 0, 0, 1, 0]],
   [[ 1, 0, 0, 0],
    [ 0, 1, 0, 0],
    [ 0, 0, 1, 0]]]
</pre><h2 id="nd.la.hessenberg_decomp">nd.la.hessenberg_decomp</h2><pre>Computes the (Upper) Hessenberg Decomposition of a matrix. It
is worth mentioning that the Hessenberg Decomposition of a
symmetric matrix is tridiagonal.

Parameters
----------
A: NDArray[...,N,N]
  The matrix for which the Hessemberg Decomposition is computed.

Returns
-------
U: NDArray[...,N,N]
  An orthogonal matrix, i.e. `U @ U.T == U.T @ U == nd.la.eye(N)`.
H: NDArray[...,N,N]
  An upper Hessemberg matrix, i.e. `nd.la.tril(H,-2) == 0`, such that `U @ H @ U.T == A`.
</pre><h2 id="nd.la.lstsq">nd.la.lstsq</h2><pre>No documentation available.</pre><h2 id="nd.la.lu_decomp">nd.la.lu_decomp</h2><pre>Given an `NDArray` of square matrices, this method Computes the
LU(P) decomposition with Column Pivotization.

Parameters
----------
A: NDArray[...,N,N]

Returns
-------
LU: NDArray[...,N,N]
  A matrix containing both the lower and upper triangular part of the
  LU decomposition. The diagonal of ther lower triangular matrix L
  is not contained in LU. It only containes ones and is implied.
P : NDArray[...,N]
  The order in which the row indices of A appear in the LU decomposition, i.e.:
  `A(P[i],j) == (L @ U)[i,j]`.
</pre><h2 id="nd.la.lu_solve">nd.la.lu_solve</h2><pre>Given the LU(P) decomposition and the right hand side of a
Linear Equations System, this method computes the result of
said system.

Parameters
----------
LU: NDArray[...,N,N]
P : NDArray[...,N]
y : NDArray[...,N,M]

Returns
-------
x : NDArray[...,N,M]
  The solution of the Linear Equation System, such that:
  `y[P[i],:] == (L @ U @ x)[i,:] `
</pre><h2 id="nd.la.matmul2">nd.la.matmul2</h2><pre>Computes the matrix product of exactly two matrices. The last two axes
are considered to be the matrix dimensions. For the leading axes,
broadcasting rules apply. Along with `nd.la.matmul`, this is one
of the only two methods that currently allows complex inputs.

Parameters
----------
a: NDArray[...,N,K]
  The left factor matrices.
b: NDArray[...,K,M]
  The right factor matrices.

Returns
-------
product: NDArray[...,N,M]
  Where `product = a @ b`.

Examples
--------
&gt;&gt;&gt; const A = [
...   [2, 0],
...   [0,-1]
... ];
&gt;&gt;&gt; const x = nd.array([
...   [[1,2]],
...   [[3,4]],
...   [[5,6]]
... ]).T;
&gt;&gt;&gt; console.log( x.toString() );
  [ [[1],
     [2]],

    [[3],
     [4]],

    [[5],
     [6]] ]
&gt;&gt;&gt; const y = nd.la.matmul2(A,x);
&gt;&gt;&gt; console.log( y.toString() );
  [ [[ 2 ],
     [-2 ]],
  
    [[ 6 ],
     [-4 ]],
  
    [[10 ],
     [-6 ]] ]
</pre><h2 id="nd.la.matmul">nd.la.matmul</h2><pre>Computes the matrix product of a series of matrices. The order
of multiplications is optimized to minimize the number of floating
point operations required. The last two axes are considered to be
the matrix dimensions. For the leading axes, broadcasting rules apply.
Along with `nd.la.matmul2`, this is one of the only two methods
that currently allows complex inputs.

Parameters
----------
matrices: ...NDArray
  The matrices that are to be multiplied.

Returns
-------
product: NDArray
  Where `product = matrices[0] @ matrices[1] @ ... @ matrices[n-1]`.

Examples
--------
&gt;&gt;&gt; const v = nd.tabulate([1e6,1], () =&gt; 1);
&gt;&gt;&gt; console.log( v.toString() );
  [[ 1 ],
   [ 1 ],
   [ 1 ],
   [ 1 ],
   [ 1 ],
   ...999990 more...,
   [ 1 ],
   [ 1 ],
   [ 1 ],
   [ 1 ],
   [ 1 ]]
&gt;&gt;&gt; const u = nd.la.matmul(v,v.T,v,v.T,v);
&gt;&gt;&gt; console.log( u.toString() );
  [[1000000000000],
   [1000000000000],
   [1000000000000],
   [1000000000000],
   [1000000000000],
   ...999990 more...,
   [1000000000000],
   [1000000000000],
   [1000000000000],
   [1000000000000],
   [1000000000000]]
</pre><h2 id="nd.la.norm">nd.la.norm</h2><pre>No documentation available.</pre><h2 id="nd.la.permute_rows">nd.la.permute_rows</h2><pre>No documentation available.</pre><h2 id="nd.la.permute_cols">nd.la.permute_cols</h2><pre>No documentation available.</pre><h2 id="nd.la.unpermute_rows">nd.la.unpermute_rows</h2><pre>No documentation available.</pre><h2 id="nd.la.unpermute_cols">nd.la.unpermute_cols</h2><pre>No documentation available.</pre><h2 id="nd.la.qr_decomp_full">nd.la.qr_decomp_full</h2><pre>Computes the (full) QR Decomposition of a matrix. The QR
Decomposition can be used to solve both Linear Equations
and Linear Least Square problems with high numeric accuracy.
Under normal circumstances, the incomplete QR Decomposition
(`nd.la.qr_decomp`) is to be preferred over this method
as it may be significantly more memory efficient.

Parameters
----------
A: NDArray[...,N,M]
  The matrix for which the QR Decomposition is computed.

Returns
-------
Q: NDArray[...,N,N]
  An orthogonal square matrix, i.e. `Q @ Q.T == Q.T @ Q == nd.la.eye(N)`.
R: NDArray[...,N,M]
  An upper triangular matrix, such that: `A = Q @ R`
</pre><h2 id="nd.la.qr_decomp">nd.la.qr_decomp</h2><pre>Computes the (economic) QR Decomposition of a matrix. The
QR Decomposition can be used to solve both Linear Equations
and Linear Least Square problems with high numeric accuracy.
Under normal circumstances, this method is to
be preferred over the full QR Decomposition (`nd.la.qr_decomp_full`)
as it may be significantly more memory efficient.

Parameters
----------
A: NDArray[...,N,M]
  The matrix for which the QR Decomposition is computed.

Returns
-------
Q: NDArray[...,N,min(N,M)]
  An orthogonal rectangular matrix, i.e. `Q.T @ Q == nd.la.eye(min(N,M))`.
R: NDArray[...,min(N,M),M]
  An upper triangular matrix, such that: `A = Q @ R`
</pre><h2 id="nd.la.qr_lstsq">nd.la.qr_lstsq</h2><pre>Given the QR Decompostion and the right hand side of a full-rank
linear equation system, this method solves it. If the Linear
Equation System is under-determined, the Linear Least Square
solution is computed. This method is no suited for rank-deficient
or under-determined systems, in which case `rrqr_lstsq` or
`svd_lstsq` can be used instead.

Parameters
----------
Q: NDArray[...,N,K]
  The orthognal rectangular matrix of the QR Decomposition.
R: NDArray[...,K,M]
  The upper triangular matrix of the QR Decomposition.
y: NDArray[...,N,L]
  The right hand side of the Linear Equation System.

Returns
-------
x: NDArray[...,N,L]
  Such that `‖(Q @ R @ x) - y‖₂` is minimal.
</pre><h2 id="nd.la.rank">nd.la.rank</h2><pre>No documentation available.</pre><h2 id="nd.la.rrqr_decomp">nd.la.rrqr_decomp</h2><pre>Computes the economic Rank-Revealing QR Decomposition of a matrix.

Parameters
----------
A: NDArray[...,N,M]
  The matrix for which the QR Decomposition is computed.

Returns
-------
Q: NDArray[...,N,min(N,M)]
  An orthogonal rectangular matrix, i.e. `Q.T @ Q == nd.la.eye(min(N,M))`.
R: NDArray[...,min(N,M),M]
  An upper triangular matrix, where `R[i,i] &gt;= R[j,j]` if and only if `i &lt;= j`.
P: NDArray[...,M]
  The permuted column indices, such that:
  `(Q @ R)[:,j] == A[:,P[j]]`
</pre><h2 id="nd.la.rrqr_decomp_full">nd.la.rrqr_decomp_full</h2><pre>No documentation available.</pre><h2 id="nd.la.rrqr_rank">nd.la.rrqr_rank</h2><pre>No documentation available.</pre><h2 id="nd.la.rrqr_lstsq">nd.la.rrqr_lstsq</h2><pre>No documentation available.</pre><h2 id="nd.la.rrqr_solve">nd.la.rrqr_solve</h2><pre>No documentation available.</pre><h2 id="nd.la.schur_eigenvals">nd.la.schur_eigenvals</h2><pre>No documentation available.</pre><h2 id="nd.la.schur_eigen">nd.la.schur_eigen</h2><pre>No documentation available.</pre><h2 id="nd.la.schur_decomp">nd.la.schur_decomp</h2><pre>Computes the (real) Schur Decomposition of a matrix. The
Schur Decomposition is used to compute the Eigenvalues and
Eigenvectors.

Parameters
----------
A: NDArray[...,N,N]

Returns
-------
Q: NDArray[...,N,N]
  An orthogonal square matrix.
T: NDArray[...,N,N]
  An upper quasi-triangular matrix, such that `Q @ T @ Q.T == A`.
  The diagonal of T consists of 2x2 blocks that represent complex
  eigenpairs and 1x1 matrix that represent a real eigenvalue.
</pre><h2 id="nd.la.SingularMatrixSolveError">nd.la.SingularMatrixSolveError</h2><pre>No documentation available.</pre><h2 id="nd.la.solve">nd.la.solve</h2><pre>Solves a full-rank Linear Equations System (LES). The method tries to
detect rank-deficient systems and throw a `SingularMatrixSolveError`,
which contains some least squares solution to the rank-deficient
system as property `x`.

Parameters
----------
A: NDArray[...,N,K]
  The matrix of the LES.
y: NDArray[...,K,M]
  The right hand side of the LES.

Returns
-------
x: NDArray[...,N,M]
  The solution of `(A @ x) = y`.
</pre><h2 id="nd.la.svd_decomp">nd.la.svd_decomp</h2><pre>Computes the Singular Value Decomposition (SVD) of a matrix.

Parameters
----------
A: NDArray[...,N,M]
  The matrix for which the SVD is computed.

Returns
-------
U : NDArray[...,N,min(N,M)]
  An orthogonal, rectangular matrix.
sv: NDArray[..., min(N,M) ]
  The singular values of A sorted in descending order.
V : NDArray[...,min(N,M),M]
  An orthogonal, rectangular matrix, such that `A == U @ diag(sv) @ V`.
</pre><h2 id="nd.la.svd_rank">nd.la.svd_rank</h2><pre>No documentation available.</pre><h2 id="nd.la.svd_solve">nd.la.svd_solve</h2><pre>No documentation available.</pre><h2 id="nd.la.svd_lstsq">nd.la.svd_lstsq</h2><pre>No documentation available.</pre><h2 id="nd.la.svd_jac_2sided">nd.la.svd_jac_2sided</h2><pre>Computes the Singular Value Decomposition (SVD) of a matrix.

Parameters
----------
A: NDArray[...,N,M]
  The matrix for which the SVD is computed.

Returns
-------
U : NDArray[...,N,min(N,M)]
  An orthogonal, rectangular matrix.
sv: NDArray[..., min(N,M) ]
  The singular values of A sorted in descending order.
V : NDArray[...,min(N,M),M]
  An orthogonal, rectangular matrix, such that `A == U @ diag(sv) @ V`.
</pre><h2 id="nd.la.svd_jac_2sided_blocked">nd.la.svd_jac_2sided_blocked</h2><pre>No documentation available.</pre><h2 id="nd.la.svd_jac_classic">nd.la.svd_jac_classic</h2><pre>No documentation available.</pre><h2 id="nd.la.tril">nd.la.tril</h2><pre>Returns a copy of an array with all entries outside of the lower triangular part set to 0.
The last two axes are considered the matrix dimensions.

Parameters
----------
A: NDArray[...,N,M]
  The array of matrices whose lower triangular parts are to be returned.
offset: int
  [Optional] The offset from the main diagonal of entries included in the  result.
  If `offset = +1` the entries above/right of the main diagonal are not set to zero.
  If `offset = -2` the entries on the main diagonal and one below/left of if are set to zero.
  The default value is 0.

Returns
-------
L: NDArray[...,N,M]
  The lower triangular part of A, where `L(i,j) == i &gt;= j-offset ? A(i,j) : 0`.

Examples
--------
&gt;&gt;&gt; const A = nd.tabulate([2,3,3], (k,i,j) =&gt; 100*(k+1) + 10*(i+1) + (j+i) );
&gt;&gt;&gt; console.log( A.toString() );
  [[[ 110, 111, 112 ],
    [ 121, 122, 123 ],
    [ 132, 133, 134 ]],
   [[ 210, 211, 212 ],
    [ 221, 222, 223 ],
    [ 232, 233, 234 ]]]

&gt;&gt;&gt; const L1 = nd.la.tril(A);
&gt;&gt;&gt; console.log( L1.toString() );
  [[[ 110,   0,   0 ],
    [ 121, 122,   0 ],
    [ 132, 133, 134 ]],
   [[ 210,   0,   0 ],
    [ 221, 222,   0 ],
    [ 232, 233, 234 ]]]
&gt;&gt;&gt; const L2 = nd.la.tril(A,-1);
&gt;&gt;&gt; console.log( L2.toString() );
  [[[   0,   0,  0 ],
    [ 121,   0,  0 ],
    [ 132, 133,  0 ]],
   [[   0,   0,  0 ],
    [ 221,   0,  0 ],
    [ 232, 233,  0 ]]]
</pre><h2 id="nd.la.triu">nd.la.triu</h2><pre>Returns a copy of an array with all entries outside of the upper triangular part set to 0.
The last two axes are considered the matrix dimensions.

Parameters
----------
A: NDArray[...,N,M]
  The array of matrices whose upper triangular parts are to be returned.
offset: int
  [Optional] The offset from the main diagonal of entries included in the result.
  If `offset = +1` the main diagonal is set to zero.
  If `offset = -2` the entries on the main diagonal and one below/left of if are not set to zero.
  The default value is 0.

Returns
-------
U: NDArray[...,N,M]
  The upper triangular part of A, where `L(i,j) == i &lt;= j-offset ? A(i,j) : 0`.

Examples
--------
&gt;&gt;&gt; const A = nd.tabulate([2,3,3], (k,i,j) =&gt; 100*(k+1) + 10*(i+1) + (j+i) );
&gt;&gt;&gt; console.log( A.toString() );
  [[[ 110, 111, 112 ],
    [ 121, 122, 123 ],
    [ 132, 133, 134 ]],
   [[ 210, 211, 212 ],
    [ 221, 222, 223 ],
    [ 232, 233, 234 ]]]

&gt;&gt;&gt; const L1 = nd.la.triu(A);
&gt;&gt;&gt; console.log( L1.toString() );
[[[ 110, 111, 112 ],
  [   0, 122, 123 ],
  [   0,   0, 134 ]],
 [[ 210, 211, 212 ],
  [   0, 222, 223 ],
  [   0,   0, 234 ]]]
&gt;&gt;&gt; const L2 = nd.la.triu(A,+1);
&gt;&gt;&gt; console.log( L2.toString() );
[[[ 0, 111, 112 ],
  [ 0,   0, 123 ],
  [ 0,   0,   0 ]],
 [[ 0, 211, 212 ],
  [ 0,   0, 223 ],
  [ 0,   0,   0 ]]]
</pre><h2 id="nd.la.tril_solve">nd.la.tril_solve</h2><pre>Given the lower triangular (square) matrix and the right hand side of a linear
equation system, this method computes the result.

Parameters
----------
L: NDArray[...,N,N]
  The lower triangular matrix of the linear equations system. L is assumed to
  be lower triangular without ever looking at the values in the upper triangular
  region.
y: NDArray[...,N,M]
  The right hand side matrix of the linear equation system.

Returns
-------
x: NDArray[...,N,M]
  Such that `L @ x = y`.
</pre><h2 id="nd.la.triu_solve">nd.la.triu_solve</h2><pre>Given the upper triangular (square) matrix and the right hand side of a linear
equation system, this method computes the result.

Parameters
----------
U: NDArray[...,N,N]
  The upper triangular matrix of the linear equations system. U is assumed to
  be upper triangular without ever looking at the values in the lower triangular
  region.
y: NDArray[...,N,M]
  The right hand side matrix of the linear equation system.

Returns
-------
x: NDArray[...,N,M]
  Such that `U @ x = y`.
</pre><h2 id="nd.opt.line_search">nd.opt.line_search</h2><pre>No documentation available.</pre><h2 id="nd.opt.min_lbfgs_gen">nd.opt.min_lbfgs_gen</h2><pre>Iteratively minimizes a function using the L-BFGS method. An indefinite number of solutions is
returned unless the line search does not make any further progress, in which case a
`LineSearchNoProgressError` is thrown. The user must check for a proper stopping condition
her-/himself.

Parameters
----------
fg: (x: NDArray[N]) =&gt; [f: NDArray[], g: NDArray[N]]
  A method return both the function value and gradients of the optimized function for
  the given input `x`. 
x0: NDArray[N]
  The starting point for the minimization.
options: {
  historySize=8: int
    The number of past value-gradient pairs that are memoized in order to approximate the Hessian.
  lineSearch=nd.opt.line_search.strong_wolfe()
    The line search method used to advance the solution along the current search direction.
    Must at least satisfy the Wolfe Condition.
  negDir0 = g=&gt;g: (g: NDArray[N]) =&gt; (negDir: NDArray[N])
    Returns the gradient-descent-like initial search direction. Can be used to control the initial
    search step.
}

Returns
-------
approximations: Iterator&lt;[x: NDArray[N], f: NDArray[] g: NDArray[N]]&gt;
  An iterator over the approximations/iterations made by the L-BFGS method. Will return an indefinite
  amount of approximations unless a `LineSearchNoProgressError` is thrown.

Throws
------
noProgress: nd.opt.LineSearchNoProgressError
  If the optimization is not making any more progress. This is usally happens when the optimizer
  is already very close to the minimum.

References
----------
.. [1] https://en.wikipedia.org/wiki/Limited-memory_BFGS
.. [2] https://en.wikipedia.org/wiki/Wolfe_conditions

Example
-------
&gt;&gt;&gt; const fg = ([x,y]) =&gt; [
...   nd.array(  (x-1)**2 + 100*(y-x*x)**2 ),
...   nd.array([ (x-1) *2 - 400*(y-x*x) *x,
...                         200*(y-x*x) ])
... ];
... let x,f,g, nIter = -1;
... try {
...   for( [x,f,g] of nd.opt.min_lbfgs_gen(fg, /*x0=*/[0,0], {negDir: g =&gt; g.mapElems(x =&gt; x*0.1)}) )
...   {
...     const gNorm = g.reduceElems(nd.math.hypot);
...     if( ++nIter &gt; 1e3 )
...       throw new Error('Too many iterations.');
...     if( gNorm &lt;= 1e-8 )
...       break;
...   }
... }
... catch(err) {
...   if( ! (err instanceof nd.opt.LineSearchNoProgressError) )
...     throw err;
...   console.log('No progress.');
... }
... console.log('Solution:', x);
  Solution: [ 0.9999999998879853, 0.9999999997700713 ]
</pre><h2 id="nd.opt.strong_wolfe">nd.opt.strong_wolfe</h2><pre>No documentation available.</pre><h2 id="nd.opt.num_grad">nd.opt.num_grad</h2><pre>No documentation available.</pre><h2 id="nd.opt.root1d_bisect">nd.opt.root1d_bisect</h2><pre>No documentation available.</pre><h2 id="nd.opt.line_search.strong_wolfe">nd.opt.line_search.strong_wolfe</h2><pre>No documentation available.</pre><h2 id="nd.io.IS_LITTLE_ENDIAN">nd.io.IS_LITTLE_ENDIAN</h2><pre>No documentation available.</pre><h2 id="nd.io.WHITESPACES">nd.io.WHITESPACES</h2><pre>No documentation available.</pre><h2 id="nd.io.b64_decode">nd.io.b64_decode</h2><pre>No documentation available.</pre><h2 id="nd.io.b64_decode_gen">nd.io.b64_decode_gen</h2><pre>No documentation available.</pre><h2 id="nd.io.b64_encode">nd.io.b64_encode</h2><pre>No documentation available.</pre><h2 id="nd.io.b64_encode_gen">nd.io.b64_encode_gen</h2><pre>No documentation available.</pre><h2 id="nd.io.istr_parse">nd.io.istr_parse</h2><pre>Parses an inlineable string representation (ISTR) of an `NDArray`. ISTR is intended
for inlining large `NDArray`s into JavaScript code or JSON files. The string representation
consists of a data type string, followed by a JSON array for the shape and finally a Base64
encoded, little-endian representation of the `NDArray`'s data/content. Except for within
the type string or in between the digits of a shape integer, ISTR is whitespace-agnostic.

Parameters
----------
chars: Iterable<char>
  The character sequence that is to be parsed.

Returns
-------
ndarray: NDArray
  The `NDArray` parsed from `chars`.

Examples
--------
&gt;&gt;&gt; const a = nd.io.istr_parse(`int32[7,6]
...   CwAAAAwAAAANAAAADgAAAA8AAAAQAAAAFQAAABYAAAAXAAAAGAAAABkAAAAaAAAAHwAAACAAAAAhAAAAIgAAACMAAAAkAAAAKQAAACoAAAArAAAALAAAAC0AAAAuAAAA
...   MwAAADQAAAA1AAAANgAAADcAAAA4AAAAPQAAAD4AAAA/AAAAQAAAAEEAAABCAAAARwAAAEgAAABJAAAASgAAAEsAAABMAAAA`
... );
&gt;&gt;&gt; console.log( a.toString() )
  [[ 11, 12, 13, 14, 15, 16 ],
   [ 21, 22, 23, 24, 25, 26 ],
   [ 31, 32, 33, 34, 35, 36 ],
   [ 41, 42, 43, 44, 45, 46 ],
   [ 51, 52, 53, 54, 55, 56 ],
   [ 61, 62, 63, 64, 65, 66 ],
   [ 71, 72, 73, 74, 75, 76 ]]
</char></pre><h2 id="nd.io.istr_stringify">nd.io.istr_stringify</h2><pre>Converts an `NDArray` into an inlineable string representation (ISTR). ISTR is intended
for inlining large `NDArray`s into JavaScript code or JSON files. The string representation
consists of a data type string, followed by a JSON array for the shape and finally a Base64
encoded, little-endian representation of the `NDArray`'s data/content. Except for within
the type string or in between the digits of a shape integer, ISTR is whitespace-agnostic.

Parameters
----------
ndarray: NDArray
  The array that is to be converted to an inlineable string representation.
options: {linewidth=128}
  [optional] The maximum number of Base64 characters per line before a newline
  character is inserted.

Returns
-------
istr: string
  An inlineable string representation of `ndarray`.

Examples
--------
&gt;&gt;&gt; const a = nd.tabulate([7,6], 'int32', (i,j) =&gt; 10*i+j+11)
&gt;&gt;&gt; console.log('`' + nd.io.istr_stringify(a) + '`')
  `int32[7,6]
  CwAAAAwAAAANAAAADgAAAA8AAAAQAAAAFQAAABYAAAAXAAAAGAAAABkAAAAaAAAAHwAAACAAAAAhAAAAIgAAACMAAAAkAAAAKQAAACoAAAArAAAALAAAAC0AAAAuAAAA
  MwAAADQAAAA1AAAANgAAADcAAAA4AAAAPQAAAD4AAAA/AAAAQAAAAEEAAABCAAAARwAAAEgAAABJAAAASgAAAEsAAABMAAAA`
</pre><h2 id="nd.io.istr_stringify_gen">nd.io.istr_stringify_gen</h2><pre>No documentation available.</pre><h2 id="nd.io.npy_serialize">nd.io.npy_serialize</h2><pre>Serializes an `NDArray` into an `Uint8Array` using version 1.0 of the NumPy NPY-format.
NPY is popular matrix exchange format that is implemented in several programming languages.
It is well-suited for network streaming or file system storage.

In order to reduce memory overhead, consider using `nd.io.npy_serialize_gen()` which returns
an `Iterable<uint8>` instead of an `Uint8Array`.

Parameters
----------
ndarray: NDArray
  The array that is to be serialized.

Returns
-------
bytes: Uint8Array
  The bytes of the NPY representation of `ndarray`.
</uint8></pre><h2 id="nd.io.npy_serialize_gen">nd.io.npy_serialize_gen</h2><pre>No documentation available.</pre><h2 id="nd.io.npy_deserialize">nd.io.npy_deserialize</h2><pre>No documentation available.</pre><h2 id="nd.dt.ARRAY_TYPES">nd.dt.ARRAY_TYPES</h2><pre>No documentation available.</pre><h2 id="nd.dt.eps">nd.dt.eps</h2><pre>No documentation available.</pre><h2 id="nd.dt.cast_scalar">nd.dt.cast_scalar</h2><pre>No documentation available.</pre><h2 id="nd.dt._check_dtype">nd.dt._check_dtype</h2><pre>No documentation available.</pre><h2 id="nd.dt.dtypeof">nd.dt.dtypeof</h2><pre>No documentation available.</pre><h2 id="nd.dt.super_dtype">nd.dt.super_dtype</h2><pre>No documentation available.</pre><h2 id="nd.dt.is_subdtype">nd.dt.is_subdtype</h2><pre>No documentation available.</pre><h2 id="nd.dt.Complex">nd.dt.Complex</h2><pre>Rudimentary implementation of the Complex number type, used
mainly for the calculation of eigenvalues. Other than that,
complex dtype is not yet supported in NDJS.
</pre><h2 id="nd.dt.Complex128Array">nd.dt.Complex128Array</h2><pre>No documentation available.</pre><h2 id="nd.NDArray.length_STATIC">nd.NDArray.length [STATIC]</h2><pre>No documentation available.</pre><h2 id="nd.NDArray.name_STATIC">nd.NDArray.name [STATIC]</h2><pre>No documentation available.</pre><h2 id="nd.NDArray.prototype_STATIC">nd.NDArray.prototype [STATIC]</h2><pre>No documentation available.</pre><h2 id="nd.NDArray.constructor">nd.NDArray.constructor</h2><pre>An n-dimensional, axis-aligned grid of entries, very similar
to NumPy ndarrays in Python.

Attributes
----------
shape: int[]
  The shape of the NDArray.
data : dtype[]
  The flat data array backing this NDArray. May be either
  a standard JavaScript Array, or one of JavaScripts primitive
  array types. See nd.dtypes for a list of supported data types.
ndim: int
  The number of dimensions in this NDArray, i.e. the number of
  indices used to address the entries. Equivalent to shape.length.
  
dtype: String
  The data type of this NDArray. Specifies which type of values
  may be stored in the NDArray. See nd.dtypes for the available
  data types and their respective (primitive) array types.
</pre><h2 id="nd.NDArray.set">nd.NDArray.set</h2><pre>Sets the value of the specified entry to the given value.

Parameters
----------
indices: int[]
  The multi index of the entry that is to be changed.
value: dtype
  The new value for the entry at indices.

Examples
--------
&gt;&gt;&gt; let a = nd.array([ [0,0,0], [0,0,0], [0,0,0] )
&gt;&gt;&gt; a.set([0,0], 1)
&gt;&gt;&gt; a.set([0,1], 2)
&gt;&gt;&gt; a.set([1,1], 3)
&gt;&gt;&gt; a.set([2,2], 4)
&gt;&gt;&gt; console.log( a.toString() )
  [[1,2,0],
   [0,3,0],
   [0,0,4]]
</pre><h2 id="nd.NDArray.modify">nd.NDArray.modify</h2><pre>Modifies an array entriy by applying the given functions to it.
This method call is equivalent to:
`ndarray.set( indices, modifier(ndarray(...indices), ...indices) )`

Parameters
----------
indices: int[]
  The multi index of the entry that is to modified.
modifier: (dtype, ...int) =&gt; dtype
  The function that is applied to the NDArray entry.
</pre><h2 id="nd.NDArray._flat_idx">nd.NDArray._flat_idx</h2><pre>No documentation available.</pre><h2 id="nd.NDArray.toString">nd.NDArray.toString</h2><pre>Returns a readable string representation of this NDArray.

Parameters
----------
max_len: int
  [OPTIONAL] The maximum number of elements along each to be represented
  in the String. If there is more elements along an axis than that, an
  ellipsis (...) is inserted instead of the central elements.

Returns
-------
repr: String
  A readable string representation of this nd.Arrray.

Examples
--------
&gt;&gt;&gt; let a = nd.tabulate([6,6], (i,j) =&gt; 10*(i+1) + (j+1) )
&gt;&gt;&gt; console.log( a.toString() )
  [[11,12,13,14,15,16],
   [21,22,23,24,25,26],
   [31,32,33,34,35,36],
   [41,42,43,44,45,46],
   [51,52,53,54,55,56],
   [61,62,63,64,65,66]]

&gt;&gt;&gt; console.log( a.toString(4) )
  [[11, 12, ...2 more..., 15, 16],
   [21, 22, ...2 more..., 25, 26],
    ...2 more...,
   [51, 52, ...2 more..., 55, 56],
   [61, 62, ...2 more..., 65, 66]]
</pre><h2 id="nd.NDArray.toNestedArray">nd.NDArray.toNestedArray</h2><pre>No documentation available.</pre><h2 id="nd.NDArray.forEach">nd.NDArray.forEach</h2><pre>Calls the given callback for each slice of this NDArray along the
first axis. Equivalent to:

for( let i=0; i &lt; this.shape[0]; i++ )
  consumer( this.slice(i), i )

Parameters
----------
consumer: (slice: NDArray, index: int) =&gt; ()
  The callback to be called for each slice of this NDArray along the first axis.

Examples
--------
&gt;&gt;&gt; let a = nd.array([[1,2,3],[4,5,6]])
&gt;&gt;&gt; a.forEach( (row,i) =&gt; console.log(`${i} -&gt; ${row}`) )
  0 -&gt; [1,2,3]
  1 -&gt; [4,5,6]
</pre><h2 id="nd.NDArray.elems">nd.NDArray.elems</h2><pre>Returns an iterator of all multiindex-value pairs of entries in
this NDArray.

Returns
-------
iter: *[[...int], dtype]
  An iterator of multiindex-value pairs, one for each entry in this
  NDArray.

Examples
--------
&gt;&gt;&gt; a = nd.array([[1,2,3],[4,5,6]])
&gt;&gt;&gt; for( let [[i,j],a_ij] of a.entries() )
...   console.log(`a[${i},${j}] = ${val}`)
  a[0,0] = 1
  a[0,1] = 2
  a[0,2] = 3
  a[1,0] = 4
  a[1,1] = 5
  a[1,2] = 6
</pre><h2 id="nd.NDArray.forElems">nd.NDArray.forElems</h2><pre>Calls the given callback for each entry in this NDArray.

Parameters
----------
consumer: (val: dtype, indices: ...int) =&gt; ()

Examples
--------
&gt;&gt;&gt; let a = nd.array([[1,2,3],[4,5,6]])
&gt;&gt;&gt; a.forEntries( (a_ij,i,j) =&gt; console.log(`a[${i},${j}] = ${a_ij}`) )
  a[0,0] = 1
  a[0,1] = 2
  a[0,2] = 3
  a[1,0] = 4
  a[1,1] = 5
  a[1,2] = 6
</pre><h2 id="nd.NDArray.valueOf">nd.NDArray.valueOf</h2><pre>
If this NDArray is scalar (shape == []), the only entry's value is returned,
otherwise this NDArray itself is returned.

This method rarely has to be called explicitly but is used by JavaScript
whenever it deems it appropriate.

Returns
-------
value: dtype or NDArray
  Returns the only entry if this NDArray is scalar. Returns this otherwise.

Example
-------
&gt;&gt;&gt; a = nd.array(12)
&gt;&gt;&gt; console.log( a+1 )
  13
</pre><h2 id="nd.NDArray.mapElems">nd.NDArray.mapElems</h2><pre>Creates a new NDArray by applying the given mapping function to each entry
of this array and writing the results back into a new array.

Equivalent to NDArray.from(this, dtype, mapper).

Parameters
----------
dtype: String
  [OPTIONAL] The data type of the newly created NDArray.
mapper: (value, ...indices) =&gt; dtype
  The function used to map the old NDArray's entries to the values of the
  new NDArray.

Returns
-------
mapped: NDArray
  The newly created NDArray, where:
  mapped(i0,i1,...,i[n]) = mapper(this(i0,i1,...,i[n]), i0,i1,...,i[n]).

Examples
--------
&gt;&gt;&gt; let a = nd.array([[1,2],[3,4]])
&gt;&gt;&gt; let b = a.mapElems( x =&gt; x*x )
&gt;&gt;&gt; console.log( b.toString() )
  [[1, 4],
   [9,16]]
</pre><h2 id="nd.NDArray.transpose">nd.NDArray.transpose</h2><pre>Reorders the axes of this NDArray. By default the last two axes are
swapped.

Parameters
----------
axes: ...int
  The order in which the axes of the this NDArray appear in the
  transposed array. If indices are missing from `axes`, they are
  appended to `axes` in order.

Returns
-------
transposed: NDArray
  A transposed copy A of this NDArray, where:
  `A[i[0], i[1], ...]  =  this[i[axes[0]], i[axes[1], ...]`

Examples
--------
&gt;&gt;&gt; let a = nd.array([[1,2,3]])
&gt;&gt;&gt; console.log( a.transpose() )
  [[1],
   [2],
   [3]]

&gt;&gt;&gt; let a = nd.array([ [[1,2,3], [4,5,6]], [[7,8,9], [10,11,12]] ])
&gt;&gt;&gt; console.log( a.transpose(2).toString() )
  [[[ 1,  4],
    [ 7, 10]],
   [[ 2,  5],
    [ 8, 11]],
   [[ 3,  6],
    [ 9, 12]]]
</pre><h2 id="nd.NDArray.reshape">nd.NDArray.reshape</h2><pre>Returns view of this NDArray with a different shape. This is similar
to NumPy's reshape with a 'C'-order.

Parameters
----------
shape: ...int
  The shape of the view. May contain a single -1 entry, in which case
  the respective axis' size is inferred.

Returns
-------
reshaped: NDArray
  A reshaped view of this NDArray.

Examples
--------
&gt;&gt;&gt; let a = nd.array([1,2,3,4,5,6,7,8,9])
&gt;&gt;&gt; let b = a.reshape(3,-1)
&gt;&gt;&gt; console.log( b.toString() )
  [[1,2,3],
   [4,5,6],
   [7,8,9]]
</pre><h2 id="nd.NDArray.reduceElems">nd.NDArray.reduceElems</h2><pre>Uses the given binary operator to reduce the entries of of this NDArray
along the specified axes. If no axes are specified all entries are reduce
to a single value and said value is returned instead of an NDArray.

Parameters
----------
axes: int or int[]
  [OPTIONAL] The axes along which the array is to be reduced. If not defined
  the NDArray is reduced along all axes and a scalar value is returned instead
  of an NDArray.
dtype: String
  The data type of the reduced NDArray. Has to be a super-dtype of the original
  NDArray.
reducer: (dtype,dtype) =&gt; dtype
  The function used to reduce the entries along the axes.

Returns
-------
reduced: NDArray or dtype
  The reduced NDArray if axes were specified or the reduced value id no
  axes were specified.

Examples
--------
&gt;&gt;&gt; let a = nd.array([
...   [1,2,3],
...   [4,5,6]
... ])
&gt;&gt;&gt; console.log( a.reduce( (x,y) =&gt; x+y ) )
  21


&gt;&gt;&gt; console.log( a.reduce( [0,1], (x,y) =&gt; x+y ) )
  { [NDArray: self] shape: [], data: [21] }

&gt;&gt;&gt; console.log( a.reduce( 0, (x,y) =&gt; x+y ).toString() )
  [5,7,9]

&gt;&gt;&gt; console.log( a.reduce( [1], (x,y) =&gt; x+y ).toString() )
  [6,15]
</pre><h2 id="nd.NDArray.sliceElems">nd.NDArray.sliceElems</h2><pre>Extracts a sub-region specified by combination of indices, ranges, newaxis symbols.

Parameters
----------
slices: int or nd.newaxis or nd.ellipsis or [start,stop,step]
  The slices to be taken along each axis, e.g 3 would only take the fourth entries
  along an axis, [,,] would take all elements along and axis, [1,,] would take all
  but the first entries along an axis, [,,3] would take ever third element along
  an axis, [,-1,] would take all but the last entries along an axis, nd.newaxis
  would insert a new axis of size 1.

  nd.ellipsis can be used to fill up with [,,] for the remaining axes.

Returns
-------
sliced: NDArray
  A sliced subregion of this NDArray.

Examples
--------
&gt;&gt;&gt; let a = nd.array([
...   [11,12,13,14],
...   [21,22,23,24],
...   [31,32,33,34]
... ])
&gt;&gt;&gt; console.log( a.sliceElems('...', -2).toString() )
  [13, 23, 33]

&gt;&gt;&gt; console.log( a.sliceElems([,,2]).toString() )
  [[11,12,13,14],
   [31,32,33,34]]

&gt;&gt;&gt; console.log( a.sliceElems(2,[1,3,]).toString() )
  [32,33]
</pre><h2 id="nd.dt.Complex.length_STATIC">nd.dt.Complex.length [STATIC]</h2><pre>No documentation available.</pre><h2 id="nd.dt.Complex.name_STATIC">nd.dt.Complex.name [STATIC]</h2><pre>No documentation available.</pre><h2 id="nd.dt.Complex.prototype_STATIC">nd.dt.Complex.prototype [STATIC]</h2><pre>No documentation available.</pre><h2 id="nd.dt.Complex.constructor">nd.dt.Complex.constructor</h2><pre>Rudimentary implementation of the Complex number type, used
mainly for the calculation of eigenvalues. Other than that,
complex dtype is not yet supported in NDJS.
</pre><h2 id="nd.dt.Complex.add">nd.dt.Complex.add</h2><pre>No documentation available.</pre><h2 id="nd.dt.Complex.sub">nd.dt.Complex.sub</h2><pre>No documentation available.</pre><h2 id="nd.dt.Complex.mul">nd.dt.Complex.mul</h2><pre>No documentation available.</pre><h2 id="nd.dt.Complex.div">nd.dt.Complex.div</h2><pre>No documentation available.</pre><h2 id="nd.dt.Complex.equals">nd.dt.Complex.equals</h2><pre>No documentation available.</pre><h2 id="nd.dt.Complex.abs">nd.dt.Complex.abs</h2><pre>No documentation available.</pre><h2 id="nd.dt.Complex.arg">nd.dt.Complex.arg</h2><pre>No documentation available.</pre><h2 id="nd.dt.Complex.conj">nd.dt.Complex.conj</h2><pre>No documentation available.</pre><h2 id="nd.dt.Complex.toFixed">nd.dt.Complex.toFixed</h2><pre>No documentation available.</pre><h2 id="nd.dt.Complex.sqrt">nd.dt.Complex.sqrt</h2><pre>No documentation available.</pre><h2 id="nd.dt.Complex.toString">nd.dt.Complex.toString</h2><pre>No documentation available.</pre><h2 id="nd.dt.Complex.valueOf">nd.dt.Complex.valueOf</h2><pre>No documentation available.</pre></body></html>