'use strict';
/* This file is part of ND.JS.
 *
 * ND.JS is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * ND.JS is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ND.JS. If not, see <http://www.gnu.org/licenses/>.
 */

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  help: true,
  help_str: true
};
exports.help_str = exports.help = void 0;

var nd = _interopRequireWildcard(require("."));

Object.keys(nd).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return nd[key];
    }
  });
});

nd.help_str = function (func_or_obj) {
  return func_or_obj.__doc__ || 'No documentation available.';
};

nd.help = function (func_or_obj) {
  return console.log(nd.help_str(func_or_obj));
};

var help = nd.help;
exports.help = help;
var help_str = nd.help_str;
exports.help_str = help_str;
nd.dt.Complex.__doc__ = "Rudimentary implementation of the Complex number type, used\nmainly for the calculation of eigenvalues. Other than that,\ncomplex dtype is not yet supported in NDJS.\n"; //
// FACTORY METHODS
//

nd.NDArray.constructor.__doc__ = "Creates a new NDArray with given shape and data array. This\nconstructor may not create any protection copies of the given\ndata but use it directly instead. This method is intended\nfor internal use mostly. More user-friendly and convenient\nfactory methods are available like nd.array, nd.tabulate or\nNDArray.from.\n\nWARNING: This method freezes the buffer that's underlying the shape it's given.\n\nParameters\n----------\nshape: Int32Array\n  The shape of new NDArray. May be used directly (no protection\n  copy may be perfomed). The buffer behind this Int32Array will be frozen.\ndata: dtype[]\n  The flat data array to be used in this NDArray. May be used\n  directly (no protection copy may be performed).\n\nReturns\n-------\nndarray: NDArray\n  A new NDArray.\n\nExamples\n--------\n>>> a = new NDArray([2,3,2], [111,112,121,122,131,132,211,212,221,222,231,232])\n>>> console.log( a.toString() )\n  [[[111,112],\n    [121,122],\n    [131,132]],\n   [[211,212],\n    [221,222],\n    [231,232]]]\n";
nd.zip_elems.__doc__ = "Creates a new NDArray from one or more NDArrays, using a function to\nmerge the values of the NDArray(s) to the values of the new NDArray.\n\nThis can be used to perform unary (sin, cos, exp, ...) and binary\n(+, -, *, ...) operations.\n\nThis method supports NumPy-style broadcasting of the NDArray arguments.\n\nParameters\n----------\nndarray: NDArray or NDArray[]\n  The NDArray or list of NDArrays from which the new NDArray is built.\ndtype: String\n  [OPTIONAL] The data type of the new NDArray.\nmapper: (...values, ...indices) => dtype\n  A function used to determine the entry values of the new NDArray from\n  the entry values of the old NDArray(s). May be omitted if only a single\n  NDArray is given by ndarray, in which case the entry values are copied.\n\nReturns\n-------\nndarray: NDArray\n  The newly created NDArray, where:\n  ndarray(i0,i1,...,i[n]) = mapper(ndarray[0](i0,i1,...,i[n]), ndarray[1](i0,i1,...,i[n]), ..., ndarray[m](i0,i1,...,i[n]), i0,i1,...,i[n]).\n\nExamples\n--------\n>>> let a = nd.array([1,2,3,4])\n>>> let b = nd.zip_elems(a, x => x*x)\n>>> console.log( b.toString() )\n  [1, 4, 9, 16]\n\n\n>>> let c = nd.array([[1],[2]])\n>>> let d = nd.array([1,2,3,4])\n>>> let e = zip_elems([c,d], (x,y) => 10*x+y )\n>>> console.log( e.toString() )\n  [[11,12,13,14],\n   [21,22,23,24]]\n";
nd.array.__doc__ = "Tries to heuristically create an NDArray from the input. This\nmethod is usually used to create NDArrays nested arrays, which\nallows for a creation of NDArray which is well readable by\nhumans.\n\n  * If the input is an object containing a 'shape' and 'data'\n    property, a new NDArray is created using said shape and data\n    directly (creating a protection copy of data).\n  * If the input is a (possibly nested) JavaScript array-like, it\n    is converted to an NDArray, copying the array data in the\n    process. The nesting defines the shape of the resulting\n    NDArray. \n  * Otherwise the data is interpreted as a scalar value and\n    is put into an NDArray of shape [].\n\nParameters\n----------\ndtype: String\n  [Optional] The dtype of the returned NDArray.\ncontent: { length: int[], data: dtype[] } or dtype or dtype[] or dtype[][] or ...\n  The content of the returned NDArray.\n\nReturns\n-------\nndarray: NDArray\n  An NDArray representation of the content.\n\nExamples\n--------\n>>> let content = { shape: [2,3], data: [1,2,3,4,5,6] }\n>>> let a = nd.array(content)\n>>> console.log( a.toString() )\n  [[1,2,3],\n   [4,5,6]]\n>>> content.data[3] = 7\n>>> console.log( a.toString() )\n  [[1,2,3],\n   [7,5,6]]\n\n\n>>> let content = { shape: [2,3], data: [1,2,3,4,5,6] }\n>>> let a = nd.array('int32',content)\n>>> console.log( a.toString() )\n  [[1,2,3],\n   [4,5,6]]\n>>> content.data[3] = 7\n>>> console.log( a.toString() )\n  [[1,2,3],\n   [4,5,6]]\n\n\n>>> let a = nd.array([\n...   [1,2,3,4],\n...   [5,6,7,8]\n... ])\n>>> console.log( a.toString() )\n  [[1,2,3,4],\n   [5,6,7,8]]\n\n\n>>> console.log( nd.array(12) )\n  { [NDArray: self] shape: [], data: Int32Array[12] }\n";
nd.asarray.__doc__ = "Similar to `nd.array(content)` except that input is not copied if\nit already is an `NDArray`.\n\nParameters\n----------\ncontent: { length: int[], data: dtype[] } or dtype or dtype[] or dtype[][] or ...\n  The content of the returned NDArray.\n\nReturns\n-------\nndarray: NDArray\n  `ndarray = content instanceof NDArray ? content : nd.array(content);`\n";
nd.tabulate.__doc__ = "Creates a new NDArray of the given shape, calling a function for\neach entry index and using the returned value as entry value of\nthe new NDArray.\n\nParameters\n----------\nshape: int[]\n  The shape of the new NDArray.\ndtype: String\n  [OPTIONAL] The data type of the newly created NDArray.\nidx2val: (...int) => dtype\n  The function returning the entry value for a given entry index as input.\n\nReturns\n-------\nndarray: NDArray\n  The newly tabulated NDArray, where:\n  ndarray(i0,i1,...,i[n]) = idx2val(i0,i1,...i[n])\n\nExamples\n--------\n>>> let a = nd.tabulate([3,2], (i,j) => 10*(i+1) + (j+1) )\n>>> console.log( a.toString() )\n  [[11,12],\n   [21,22],\n   [31,32]]\n"; //
// GENERAL
//

nd.NDArray.__doc__ = "An n-dimensional, axis-aligned grid of entries, very similar\nto NumPy ndarrays in Python.\n\nAttributes\n----------\nshape: int[]\n  The shape of the NDArray.\ndata : dtype[]\n  The flat data array backing this NDArray. May be either\n  a standard JavaScript Array, or one of JavaScripts primitive\n  array types. See nd.dtypes for a list of supported data types.\nndim: int\n  The number of dimensions in this NDArray, i.e. the number of\n  indices used to address the entries. Equivalent to shape.length.\n  \ndtype: String\n  The data type of this NDArray. Specifies which type of values\n  may be stored in the NDArray. See nd.dtypes for the available\n  data types and their respective (primitive) array types.\n";
nd.NDArray.prototype.call.__doc__ = "Returns the value of the entry specified by the given index.\n\nParameters\n----------\nthis: NDArray\n  The array whose entry is being read.\nindices: ...int\n  The multi-index of the entry whose value is to be returned.\n\nReturns\n-------\nvalue: dtype\n\nExamples\n--------\n>>> let a = nd.array([[1,2,3],[4,5,6]])\n>>> console.log( a(0,0), a(0,1), a(0,2), a(1,0), a(1,1), a(1,2) )\n  1 2 3 4 5 6\n";
nd.NDArray.prototype.apply.__doc__ = nd.NDArray.prototype.call.__doc__;
nd.NDArray.prototype.set.__doc__ = "Sets the value of the specified entry to the given value.\n\nParameters\n----------\nindices: int[]\n  The multi index of the entry that is to be changed.\nvalue: dtype\n  The new value for the entry at indices.\n\nExamples\n--------\n>>> let a = nd.array([ [0,0,0], [0,0,0], [0,0,0] )\n>>> a.set([0,0], 1)\n>>> a.set([0,1], 2)\n>>> a.set([1,1], 3)\n>>> a.set([2,2], 4)\n>>> console.log( a.toString() )\n  [[1,2,0],\n   [0,3,0],\n   [0,0,4]]\n";
nd.NDArray.prototype.modify.__doc__ = "Modifies an array entriy by applying the given functions to it.\nThis method call is equivalent to:\n`ndarray.set( indices, modifier(ndarray(...indices), ...indices) )`\n\nParameters\n----------\nindices: int[]\n  The multi index of the entry that is to modified.\nmodifier: (dtype, ...int) => dtype\n  The function that is applied to the NDArray entry.\n";
nd.NDArray.prototype.toString.__doc__ = "Returns a readable string representation of this NDArray.\n\nParameters\n----------\nmax_len: int\n  [OPTIONAL] The maximum number of elements along each to be represented\n  in the String. If there is more elements along an axis than that, an\n  ellipsis (...) is inserted instead of the central elements.\n\nReturns\n-------\nrepr: String\n  A readable string representation of this nd.Arrray.\n\nExamples\n--------\n>>> let a = nd.tabulate([6,6], (i,j) => 10*(i+1) + (j+1) )\n>>> console.log( a.toString() )\n  [[11,12,13,14,15,16],\n   [21,22,23,24,25,26],\n   [31,32,33,34,35,36],\n   [41,42,43,44,45,46],\n   [51,52,53,54,55,56],\n   [61,62,63,64,65,66]]\n\n>>> console.log( a.toString(4) )\n  [[11, 12, ...2 more..., 15, 16],\n   [21, 22, ...2 more..., 25, 26],\n    ...2 more...,\n   [51, 52, ...2 more..., 55, 56],\n   [61, 62, ...2 more..., 65, 66]]\n"; //
// ITERATIONS
//

nd.NDArray.prototype[Symbol.iterator].__doc__ = "Returns an iterator that iterates through the slices of this NDArray along\nthe first axis. Equivalent to:\n\nfunction*() {\n  for( let i=0; i < this.shape[0]; i++ )\n    yield this.slice(i)\n}\n\nReturns\n-------\niter: Iterator\n  An iterator that yields the slices of this NDArray along its first axis.\n\nExamples\n--------\n>>> a = nd.array([[1,2],[3,4],[5,6]])\n>>> for( let row of a )\n...   console.log( row.toString() )\n  [1,2]\n  [3,4]\n  [5,6]\n";
nd.NDArray.prototype.forEach.__doc__ = "Calls the given callback for each slice of this NDArray along the\nfirst axis. Equivalent to:\n\nfor( let i=0; i < this.shape[0]; i++ )\n  consumer( this.slice(i), i )\n\nParameters\n----------\nconsumer: (slice: NDArray, index: int) => ()\n  The callback to be called for each slice of this NDArray along the first axis.\n\nExamples\n--------\n>>> let a = nd.array([[1,2,3],[4,5,6]])\n>>> a.forEach( (row,i) => console.log(`${i} -> ${row}`) )\n  0 -> [1,2,3]\n  1 -> [4,5,6]\n";
nd.NDArray.prototype.elems.__doc__ = "Returns an iterator of all multiindex-value pairs of entries in\nthis NDArray.\n\nReturns\n-------\niter: *[[...int], dtype]\n  An iterator of multiindex-value pairs, one for each entry in this\n  NDArray.\n\nExamples\n--------\n>>> a = nd.array([[1,2,3],[4,5,6]])\n>>> for( let [[i,j],a_ij] of a.entries() )\n...   console.log(`a[${i},${j}] = ${val}`)\n  a[0,0] = 1\n  a[0,1] = 2\n  a[0,2] = 3\n  a[1,0] = 4\n  a[1,1] = 5\n  a[1,2] = 6\n";
nd.NDArray.prototype.forElems.__doc__ = "Calls the given callback for each entry in this NDArray.\n\nParameters\n----------\nconsumer: (val: dtype, indices: ...int) => ()\n\nExamples\n--------\n>>> let a = nd.array([[1,2,3],[4,5,6]])\n>>> a.forEntries( (a_ij,i,j) => console.log(`a[${i},${j}] = ${a_ij}`) )\n  a[0,0] = 1\n  a[0,1] = 2\n  a[0,2] = 3\n  a[1,0] = 4\n  a[1,1] = 5\n  a[1,2] = 6\n"; //
// TRANSFORMATION
//

nd.NDArray.prototype.valueOf.__doc__ = "\nIf this NDArray is scalar (shape == []), the only entry's value is returned,\notherwise this NDArray itself is returned.\n\nThis method rarely has to be called explicitly but is used by JavaScript\nwhenever it deems it appropriate.\n\nReturns\n-------\nvalue: dtype or NDArray\n  Returns the only entry if this NDArray is scalar. Returns this otherwise.\n\nExample\n-------\n>>> a = nd.array(12)\n>>> console.log( a+1 )\n  13\n";
nd.NDArray.prototype.mapElems.__doc__ = "Creates a new NDArray by applying the given mapping function to each entry\nof this array and writing the results back into a new array.\n\nEquivalent to NDArray.from(this, dtype, mapper).\n\nParameters\n----------\ndtype: String\n  [OPTIONAL] The data type of the newly created NDArray.\nmapper: (value, ...indices) => dtype\n  The function used to map the old NDArray's entries to the values of the\n  new NDArray.\n\nReturns\n-------\nmapped: NDArray\n  The newly created NDArray, where:\n  mapped(i0,i1,...,i[n]) = mapper(this(i0,i1,...,i[n]), i0,i1,...,i[n]).\n\nExamples\n--------\n>>> let a = nd.array([[1,2],[3,4]])\n>>> let b = a.mapElems( x => x*x )\n>>> console.log( b.toString() )\n  [[1, 4],\n   [9,16]]\n";
nd.NDArray.prototype.transpose.__doc__ = "Reorders the axes of this NDArray. By default the last two axes are\nswapped.\n\nParameters\n----------\naxes: ...int\n  The order in which the axes of the this NDArray appear in the\n  transposed array. If indices are missing from `axes`, they are\n  appended to `axes` in order.\n\nReturns\n-------\ntransposed: NDArray\n  A transposed copy A of this NDArray, where:\n  `A[i[0], i[1], ...]  =  this[i[axes[0]], i[axes[1], ...]`\n\nExamples\n--------\n>>> let a = nd.array([[1,2,3]])\n>>> console.log( a.transpose() )\n  [[1],\n   [2],\n   [3]]\n\n>>> let a = nd.array([ [[1,2,3], [4,5,6]], [[7,8,9], [10,11,12]] ])\n>>> console.log( a.transpose(2).toString() )\n  [[[ 1,  4],\n    [ 7, 10]],\n   [[ 2,  5],\n    [ 8, 11]],\n   [[ 3,  6],\n    [ 9, 12]]]\n";
nd.NDArray.prototype.reshape.__doc__ = "Returns view of this NDArray with a different shape. This is similar\nto NumPy's reshape with a 'C'-order.\n\nParameters\n----------\nshape: ...int\n  The shape of the view. May contain a single -1 entry, in which case\n  the respective axis' size is inferred.\n\nReturns\n-------\nreshaped: NDArray\n  A reshaped view of this NDArray.\n\nExamples\n--------\n>>> let a = nd.array([1,2,3,4,5,6,7,8,9])\n>>> let b = a.reshape(3,-1)\n>>> console.log( b.toString() )\n  [[1,2,3],\n   [4,5,6],\n   [7,8,9]]\n";
nd.NDArray.prototype.reduceElems.__doc__ = "Uses the given binary operator to reduce the entries of of this NDArray\nalong the specified axes. If no axes are specified all entries are reduce\nto a single value and said value is returned instead of an NDArray.\n\nParameters\n----------\naxes: int or int[]\n  [OPTIONAL] The axes along which the array is to be reduced. If not defined\n  the NDArray is reduced along all axes and a scalar value is returned instead\n  of an NDArray.\ndtype: String\n  The data type of the reduced NDArray. Has to be a super-dtype of the original\n  NDArray.\nreducer: (dtype,dtype) => dtype\n  The function used to reduce the entries along the axes.\n\nReturns\n-------\nreduced: NDArray or dtype\n  The reduced NDArray if axes were specified or the reduced value id no\n  axes were specified.\n\nExamples\n--------\n>>> let a = nd.array([\n...   [1,2,3],\n...   [4,5,6]\n... ])\n>>> console.log( a.reduce( (x,y) => x+y ) )\n  21\n\n\n>>> console.log( a.reduce( [0,1], (x,y) => x+y ) )\n  { [NDArray: self] shape: [], data: [21] }\n\n>>> console.log( a.reduce( 0, (x,y) => x+y ).toString() )\n  [5,7,9]\n\n>>> console.log( a.reduce( [1], (x,y) => x+y ).toString() )\n  [6,15]\n";
nd.NDArray.prototype.sliceElems.__doc__ = "Extracts a sub-region specified by combination of indices, ranges, newaxis symbols.\n\nParameters\n----------\nslices: int or nd.newaxis or nd.ellipsis or [start,stop,step]\n  The slices to be taken along each axis, e.g 3 would only take the fourth entries\n  along an axis, [,,] would take all elements along and axis, [1,,] would take all\n  but the first entries along an axis, [,,3] would take ever third element along\n  an axis, [,-1,] would take all but the last entries along an axis, nd.newaxis\n  would insert a new axis of size 1.\n\n  nd.ellipsis can be used to fill up with [,,] for the remaining axes.\n\nReturns\n-------\nsliced: NDArray\n  A sliced subregion of this NDArray.\n\nExamples\n--------\n>>> let a = nd.array([\n...   [11,12,13,14],\n...   [21,22,23,24],\n...   [31,32,33,34]\n... ])\n>>> console.log( a.sliceElems('...', -2).toString() )\n  [13, 23, 33]\n\n>>> console.log( a.sliceElems([,,2]).toString() )\n  [[11,12,13,14],\n   [31,32,33,34]]\n\n>>> console.log( a.sliceElems(2,[1,3,]).toString() )\n  [32,33]\n";
nd.stack.__doc__ = "Arranges a list of NDArrays into a new NDArray. The NDArrays are stacked\nalong a newly axis, inserted at the specified index. All stacked NDArrays\nmust have the same shape.\n\nParameters\n----------\naxis: int\n  [OPTIONAL] The index at which the new index is to be inserted. Default value: 0.\ndtype: String\n  [OPTIONAL] The type of the stacked NDArray. Should be a super-dtype of all NDArrays'\n  dtypes.\nndarrays: NDArray[]\n  The NDArrays that are to be stacked. All NDArrays must have the same shape.\n\nReturns\n-------\nstacked: NDArray\n\nExamples\n--------\n>>> let a = nd.array([1,2,3])\n>>> let b = nd.array([4,5,6])\n>>> console.log( nd.stack([a,b]).toString )\n  [[1,2,3],\n   [4,5,6]]\n\n>>> console.log( nd.stack(1,'float64',[a,b]).toString )\n  [[1.0, 4.0],\n   [2.0, 5.0],\n   [3.0, 6.0]]\n";
nd.concat.__doc__ = "Arranges a list of NDArrays into a new NDArray. The NDArrays are concatenated\nalong an existing specified axis. Aside from said axis, the shape of all NDArrays\nmust be the same.\n\nParameters\n----------\naxis: int\n  [OPTIONAL] The axis along which the NDArrays are concatenated. Default value: 0.\ndtype: String\n  [OPTIONAL] The type of the concatenated NDArray. Should be a super-dtype of all NDArrays'\n  dtypes.\nndarrays: NDArray[]\n  The NDArrays that are to be concatenated. All NDArrays must have the same shape.\n\nReturns\n-------\nconcatenated: NDArray\n\n\nExamples\n--------\n>>> let a = nd.array([[1,2],[3,4]])\n>>> let b = nd.array([[5,6],[7,8]])\n>>> console.log( nd.concat([a,b]).toString() )\n  [[1,2],\n   [3,4],\n   [5,6],\n   [7,8]]\n   \n>>> console.log( nd.concat(1,[a,b]).toString() )\n  [[1,2,5,6],\n   [3,4,7,8]]\n";
nd.help.__doc__ = "Outputs a documentation string for the given method ND.JS method to the console. This method\nis intended to be used in interactive mode to explore and learn the ND.JS API.\n\nThis method is only available in the non-minfied version of ND.JS.\n\nParameters\n----------\nfun: Function\n  The function or package ND.JS API method for which the documentation is to be retrieved.\n\nExamples\n--------\n>>> nd.help(nd.la)\n  The Linear Algebra subpackage of ND.JS. Contains methods for the handling and decomposition\n  of matrices as well as solvers for linear equations and linear least square systems.\n\n  As convention the last two axes of an `NDArray` are considered as the matrix dimensions.\n  Higher dimensional arrays are considered \"arrays of matrices\" and the broadcasting rules\n  apply for the leading dimenions, i.e. for all dimensions of the shape except the last two.\n";
nd.help_str.__doc__ = "Returns a documentation string for the given method ND.JS method to the console. This method\nis used by `create_doc_jsdom()` to create the documentation and by `nd.help()` to\nprint help to the console.\n\nThis method is only available in the non-minfied version of ND.JS.\n\nParameters\n----------\nfun: Function\n  The function or package ND.JS API method for which the documentation is to be retrieved.\n\nReturns\n-------\nhelp: String\n  A documentation String for the given method or package.\n\nExamples\n--------\n>>> console.log( nd.help(nd.la) )\n  \"The Linear Algebra subpackage of ND.JS. Contains methods for the handling and decomposition\n   of matrices as well as solvers for linear equations and linear least square systems.\n\n   As convention the last two axes of an `NDArray` are considered as the matrix dimensions.\n   Higher dimensional arrays are considered \"arrays of matrices\" and the broadcasting rules\n   apply for the leading dimenions, i.e. for all dimensions of the shape except the last two.\"\n"; //
// OPTIMIZATION
//

nd.opt.min_lbfgs_gen.__doc__ = "Iteratively minimizes a function using the L-BFGS method. An indefinite number of solutions is\nreturned unless the line search does not make any further progress, in which case a\n`LineSearchNoProgressError` is thrown. The user must check for a proper stopping condition\nher-/himself.\n\nParameters\n----------\nfg: (x: NDArray[N]) => [f: NDArray[], g: NDArray[N]]\n  A method return both the function value and gradients of the optimized function for\n  the given input `x`. \nx0: NDArray[N]\n  The starting point for the minimization.\noptions: {\n  historySize=8: int\n    The number of past value-gradient pairs that are memoized in order to approximate the Hessian.\n  lineSearch=nd.opt.line_search.strong_wolfe()\n    The line search method used to advance the solution along the current search direction.\n    Must at least satisfy the Wolfe Condition.\n  negDir0 = g=>g: (g: NDArray[N]) => (negDir: NDArray[N])\n    Returns the gradient-descent-like initial search direction. Can be used to control the initial\n    search step.\n}\n\nReturns\n-------\napproximations: Iterator<[x: NDArray[N], f: NDArray[] g: NDArray[N]]>\n  An iterator over the approximations/iterations made by the L-BFGS method. Will return an indefinite\n  amount of approximations unless a `LineSearchNoProgressError` is thrown.\n\nThrows\n------\nnoProgress: nd.opt.LineSearchNoProgressError\n  If the optimization is not making any more progress. This is usally happens when the optimizer\n  is already very close to the minimum.\n\nReferences\n----------\n.. [1] https://en.wikipedia.org/wiki/Limited-memory_BFGS\n.. [2] https://en.wikipedia.org/wiki/Wolfe_conditions\n\nExample\n-------\n>>> const fg = ([x,y]) => [\n...   nd.array(  (x-1)**2 + 100*(y-x*x)**2 ),\n...   nd.array([ (x-1) *2 - 400*(y-x*x) *x,\n...                         200*(y-x*x) ])\n... ];\n... let x,f,g, nIter = -1;\n... try {\n...   for( [x,f,g] of nd.opt.min_lbfgs_gen(fg, /*x0=*/[0,0], {negDir: g => g.mapElems(x => x*0.1)}) )\n...   {\n...     const gNorm = g.reduceElems(nd.math.hypot);\n...     if( ++nIter > 1e3 )\n...       throw new Error('Too many iterations.');\n...     if( gNorm <= 1e-8 )\n...       break;\n...   }\n... }\n... catch(err) {\n...   if( ! (err instanceof nd.opt.LineSearchNoProgressError) )\n...     throw err;\n...   console.log('No progress.');\n... }\n... console.log('Solution:', x);\n  Solution: [ 0.9999999998879853, 0.9999999997700713 ]\n";
nd.opt.root1d_bisect.__doc__ = "Finds a single root of a continuous univariate function using the bisection method.\n\nParameters\n----------\nF: float => float\n  Continuous function for which a root is to be found.\nx1: float\n  One side of the range containing a root. F(x1) and F(x2) must have opposite signs (or be zero).\nx2: float\n  Other side of the range containing a root. F(x1) and F(x2) must have opposite signs (or be zero).\n\nReturns\n-------\nx0: float\n  A root of F, i.e. F(x0) \u2248 0.\n\nReferences\n----------\n.. [1] https://en.wikipedia.org/wiki/Bisection_method\n\nExample\n-------\n>>> const sqrt9 = nd.opt.root1d_bisect(x => x*x-9, 0, 9);\n... console.log('sqrt(9) =', sqrt9);\n  sqrt(9) = 3\n";
nd.opt.min1d_gss.__doc__ = "Finds a single minimum of a continuous univariate function using Golden Section Search.\n\nParameters\n----------\nF: float => float\n  Continuous function for which a minimum is to be found.\nx1: float\n  One side of the range containing a root. Must be left of the minimum.\nx2: float\n  Other side of the range containing a root. Must be right of the minimum.\n\nReturns\n-------\nxMin: float\n  A local minimum of F.\n\nReferences\n----------\n.. [1] https://en.wikipedia.org/wiki/Golden-section_search\n\nExample\n-------\n>>> const sqrt9 = nd.opt.min1d_gss(x => Math.abs(x*x-9), -9, +9);\n... console.log('sqrt(9) =', sqrt9);\n  sqrt(9) = 3\n";
nd.opt.fit_lin.__doc__ = "Fits a parameter-linear linear function using Linear Regression or Ridge Regression.\n\nParameters\n----------\nx: float[n_samples(,n_inputs)]\n  Function inputs of the sample points that the function is fit through.\ny: float[n_samples]\n  Function outputs of the sample points that the function is fit through.\nregularization: float\n  [optional] A regularization factor that penalizes the norm of\n  the function coefficients. The larger the regularization, the\n  smaller the coefficients tend to be, i.e. the function becomes\n  smoother and more approximative than interpolative.\nfuncs: (float[n_inputs] => float)[n_coeffs]\n  Components of the function that is to be fit through (x,y).\n  Each component has it's own linear parameter/coefficient, i.e.\n  `fit(x) = c[0]*funcs[0](x) + c[1]*funcs[1](x) + ...`.\n\nReturns\n-------\nfit {coeffs: float[n]}: float[n_coeffs]\n  A function that fits the points given by x and y. The coefficients\n  and the function components can be retrieved as `fit.coeffs` and\n  `fit.funcs` properties of the function.\n\nReferences\n----------\n.. [1] https://en.wikipedia.org/wiki/Linear_regression\n\nExample\n-------\n>>> const [a,b,c,d] = [3,1,2,4];\n... \n... // Underlying function\n... const fun = ([x,y]) => a + b*x + c*x*y + d * Math.sin(y);\n... \n... // Generate sample points to fit to\n... let X = [],\n...     Y = [];\n... for( let xi = -2; xi <= +2; xi += 0.5 ) {\n... for( let yi = -2; yi <= +2; yi += 0.5 ) {\n...   X.push(     [xi,yi]  );\n...   Y.push( fun([xi,yi]) );\n... }}\n...\n... // Fitted function\n... const fit = nd.opt.fit_lin(\n...   X,Y,\n...   [([x,y]) => Math.sin(y),\n...    ([x,y]) => x*y,\n...    ([x,y]) => x,\n...    ([x,y]) => 1]\n... );\n... \n... console.log(\n...   'Fitted coefficients: [d,c,b,a] =',\n...   [...fit.coeffs.map(x => x.toFixed(12))]\n... );\n... \n... console.log( 'fun([-1,-1]) =',  fun([-1,-1]) );\n... console.log( 'fit([-1,-1]) =',  fit([-1,-1]) );\n  Fitted coefficients: [d,c,b,a] = [ 4, 2, 1, 3 ]\n  fun([-1,-1]) = 0.634116060768414\n  fit([-1,-1]) = 0.6341160607684131\n";
nd.opt.fit_lm_gen.__doc__ = "Nonlinear least squares fit of a function to the given sample points using\nthe Levenberg-Marquardt trust region method.\n\nParameters\n----------\nx: float[n_samples,n_inputs]\n  Function inputs of the sample points that the function is fit through.\ny: float[n_samples]\n  Function outputs of the sample points that the function is fit through.\nfg: (params: float[nParam]) => (x: float[nDim]) => [f: float, g: float[nParam]]\n  Functions whose parameters are fitted. Returns the function value and its\n  gradients with respect to its parameters.\np0: float[nParam]\n  Starting values for the parameters for fitting.\nopt : {\n  r0: float\n    [optional] Starting value for trust region radius.\n  rMin: float\n    [optional] Lower trust region radius bounds.\n  rMax: float\n    [optional] Upper trust region radius bounds.\n  rTol: float\n    [optional] Relative tolerance by which the iteration adheres to the trust region radius.\n  lmLower: float \u2208 (0,1)\n    [optional] A small number that avoids that the Levenberg-Marquardt parameter becomes\n    too small too quickly during iteration.\n  shrinkLower: float \u2208 (0,shrinkUpper]\n    [optional] During a single iteration, the trust region radius may at most decrease by this factor.\n  shrinkUpper: float \u2208 [shrinkLower,1)\n    [optional] During a single iteration, the trust region radius may at least decrease by this factor.\n  grow: float\n    [optional] During a single iteration, the trust region radius may increase by this factor.\n  expectGainMin: float\n    [optional] The iteration is expected to provide at least `expectGainMin` of the predicted improvement.\n    Otherwise the trust region is shrunk.\n  expectGainMax: float\n    [optional] The iteration is expected to provide at most `expectGainMax` of the predicted improvement.\n    Otherwise the trust region is increased.\n}\n\nReturns\n-------\nIterator<[\n  p: float[nParam]\n    Current parameter values of the iteration.\n  mse: float\n    Mean squared error.\n  mse_grad: float[nParam]\n    Gradient of the mean squared error with respect to the parameters.\n  res: float[]\n    Residuals of the fit.\n  res_jac: float[]\n    Jaciobian of the residuals with respect to the parameters.\n]>\n\nReferences\n----------\n.. [1] https://en.wikipedia.org/wiki/Levenberg%E2%80%93Marquardt_algorithm\n\nExample\n-------\n>>> // Determine half-life of beer using dataset from:\n... // \"Multivariate Analyses of Beer Foam Stand\" by James J. Hackbart\n... const time = nd.array([[ 0,    15,    30,    45,    60,   90,   120,   150,   180,   210,   240,   270,   300   ]]).T,\n...     height = nd.array( [17.40, 15.10, 13.10, 11.60, 10.60, 8.70,  7.40,  6.35,  5.40,  4.50,  3.80,  3.30,  2.90] );\n... \n... // Exponential decay function.\n... const fG = ([H0, c]) => ([t]) => [\n...    H0 * 2**(-t*c),\n...   [     2**(-t*c),                    // <- d(fG) / d(H0)\n...    H0 * 2**(-t*c) * Math.log(2) * -t] // <- d(fG) / d(c)\n... ];\n... \n... for( const [[H0, c], mse, mse_grad] of nd.opt.fit_lm_gen(time, height, fG, /*p0=*/[1,1]) )\n...   if( nd.la.norm(mse_grad) <= 1e-6 ) {\n...     console.log({H0, half_life: 1/c});\n...     break;\n...   }\n  { H0: 16.386111806695105, half_life: 108.02447348677644 }\n"; //
// I/O
//

nd.io.istr_parse.__doc__ = "Parses an inlineable string representation (ISTR) of an `NDArray`. ISTR is intended\nfor inlining large `NDArray`s into JavaScript code or JSON files. The string representation\nconsists of a data type string, followed by a JSON array for the shape and finally a Base64\nencoded, little-endian representation of the `NDArray`'s data/content. Except for within\nthe type string or in between the digits of a shape integer, ISTR is whitespace-agnostic.\n\nParameters\n----------\nchars: Iterable<char>\n  The character sequence that is to be parsed.\n\nReturns\n-------\nndarray: NDArray\n  The `NDArray` parsed from `chars`.\n\nExamples\n--------\n>>> const a = nd.io.istr_parse(`int32[7,6]\n...   CwAAAAwAAAANAAAADgAAAA8AAAAQAAAAFQAAABYAAAAXAAAAGAAAABkAAAAaAAAAHwAAACAAAAAhAAAAIgAAACMAAAAkAAAAKQAAACoAAAArAAAALAAAAC0AAAAuAAAA\n...   MwAAADQAAAA1AAAANgAAADcAAAA4AAAAPQAAAD4AAAA/AAAAQAAAAEEAAABCAAAARwAAAEgAAABJAAAASgAAAEsAAABMAAAA`\n... );\n>>> console.log( a.toString() )\n  [[ 11, 12, 13, 14, 15, 16 ],\n   [ 21, 22, 23, 24, 25, 26 ],\n   [ 31, 32, 33, 34, 35, 36 ],\n   [ 41, 42, 43, 44, 45, 46 ],\n   [ 51, 52, 53, 54, 55, 56 ],\n   [ 61, 62, 63, 64, 65, 66 ],\n   [ 71, 72, 73, 74, 75, 76 ]]\n";
nd.io.istr_stringify.__doc__ = "Converts an `NDArray` into an inlineable string representation (ISTR). ISTR is intended\nfor inlining large `NDArray`s into JavaScript code or JSON files. The string representation\nconsists of a data type string, followed by a JSON array for the shape and finally a Base64\nencoded, little-endian representation of the `NDArray`'s data/content. Except for within\nthe type string or in between the digits of a shape integer, ISTR is whitespace-agnostic.\n\nParameters\n----------\nndarray: NDArray\n  The array that is to be converted to an inlineable string representation.\noptions: {linewidth=128}\n  [optional] The maximum number of Base64 characters per line before a newline\n  character is inserted.\n\nReturns\n-------\nistr: string\n  An inlineable string representation of `ndarray`.\n\nExamples\n--------\n>>> const a = nd.tabulate([7,6], 'int32', (i,j) => 10*i+j+11)\n>>> console.log('`' + nd.io.istr_stringify(a) + '`')\n  `int32[7,6]\n  CwAAAAwAAAANAAAADgAAAA8AAAAQAAAAFQAAABYAAAAXAAAAGAAAABkAAAAaAAAAHwAAACAAAAAhAAAAIgAAACMAAAAkAAAAKQAAACoAAAArAAAALAAAAC0AAAAuAAAA\n  MwAAADQAAAA1AAAANgAAADcAAAA4AAAAPQAAAD4AAAA/AAAAQAAAAEEAAABCAAAARwAAAEgAAABJAAAASgAAAEsAAABMAAAA`\n";
nd.io.npy_serialize.__doc__ = "Serializes an `NDArray` into an `Uint8Array` using version 1.0 of the NumPy NPY-format.\nNPY is popular matrix exchange format that is implemented in several programming languages.\nIt is well-suited for network streaming or file system storage.\n\nIn order to reduce memory overhead, consider using `nd.io.npy_serialize_gen()` which returns\nan `Iterable<uint8>` instead of an `Uint8Array`.\n\nParameters\n----------\nndarray: NDArray\n  The array that is to be serialized.\n\nReturns\n-------\nbytes: Uint8Array\n  The bytes of the NPY representation of `ndarray`.\n"; //
// LINEAR ALGEBRA
//

nd.la.__doc__ = "The Linear Algebra subpackage of ND.JS. Contains methods for the handling and decomposition\nof matrices as well as solvers for linear equations and linear least square systems.\n\nAs convention the last two axes of an `NDArray` are considered as the matrix dimensions.\nHigher dimensional arrays are considered \"arrays of matrices\" and the broadcasting rules\napply for the leading dimenions, i.e. for all dimensions of the shape except the last two.\n";
nd.la.eye.__doc__ = "Returns an NDArray of identity matrices, where the last two axes are the matrix dimensions.\n\nParameters\n----------\nshape: ...int\n  The shape of the resulting array. If only one value N is given, an N*N identity\n  matrix is returned.\n\nReturns\n-------\nI: NDArray\n  The array of identity matrices, where the last two axes are the matrix dimensions.\n\nExamples\n--------\n>>> const I = nd.la.eye(2);\n>>> console.log( I.toString() );\n  [[1,0],\n   [0,1]]\n\n>>> const J = nd.la.eye(2,3,4);\n>>> console.log( J.toString() );\n  [[[ 1, 0, 0, 0],\n    [ 0, 1, 0, 0],\n    [ 0, 0, 1, 0]],\n   [[ 1, 0, 0, 0],\n    [ 0, 1, 0, 0],\n    [ 0, 0, 1, 0]]]\n";
nd.la.tril.__doc__ = "Returns a copy of an array with all entries outside of the lower triangular part set to 0.\nThe last two axes are considered the matrix dimensions.\n\nParameters\n----------\nA: NDArray[...,N,M]\n  The array of matrices whose lower triangular parts are to be returned.\noffset: int\n  [Optional] The offset from the main diagonal of entries included in the  result.\n  If `offset = +1` the entries above/right of the main diagonal are not set to zero.\n  If `offset = -2` the entries on the main diagonal and one below/left of if are set to zero.\n  The default value is 0.\n\nReturns\n-------\nL: NDArray[...,N,M]\n  The lower triangular part of A, where `L(i,j) == i >= j-offset ? A(i,j) : 0`.\n\nExamples\n--------\n>>> const A = nd.tabulate([2,3,3], (k,i,j) => 100*(k+1) + 10*(i+1) + (j+i) );\n>>> console.log( A.toString() );\n  [[[ 110, 111, 112 ],\n    [ 121, 122, 123 ],\n    [ 132, 133, 134 ]],\n   [[ 210, 211, 212 ],\n    [ 221, 222, 223 ],\n    [ 232, 233, 234 ]]]\n\n>>> const L1 = nd.la.tril(A);\n>>> console.log( L1.toString() );\n  [[[ 110,   0,   0 ],\n    [ 121, 122,   0 ],\n    [ 132, 133, 134 ]],\n   [[ 210,   0,   0 ],\n    [ 221, 222,   0 ],\n    [ 232, 233, 234 ]]]\n>>> const L2 = nd.la.tril(A,-1);\n>>> console.log( L2.toString() );\n  [[[   0,   0,  0 ],\n    [ 121,   0,  0 ],\n    [ 132, 133,  0 ]],\n   [[   0,   0,  0 ],\n    [ 221,   0,  0 ],\n    [ 232, 233,  0 ]]]\n";
nd.la.triu.__doc__ = "Returns a copy of an array with all entries outside of the upper triangular part set to 0.\nThe last two axes are considered the matrix dimensions.\n\nParameters\n----------\nA: NDArray[...,N,M]\n  The array of matrices whose upper triangular parts are to be returned.\noffset: int\n  [Optional] The offset from the main diagonal of entries included in the result.\n  If `offset = +1` the main diagonal is set to zero.\n  If `offset = -2` the entries on the main diagonal and one below/left of if are not set to zero.\n  The default value is 0.\n\nReturns\n-------\nU: NDArray[...,N,M]\n  The upper triangular part of A, where `L(i,j) == i <= j-offset ? A(i,j) : 0`.\n\nExamples\n--------\n>>> const A = nd.tabulate([2,3,3], (k,i,j) => 100*(k+1) + 10*(i+1) + (j+i) );\n>>> console.log( A.toString() );\n  [[[ 110, 111, 112 ],\n    [ 121, 122, 123 ],\n    [ 132, 133, 134 ]],\n   [[ 210, 211, 212 ],\n    [ 221, 222, 223 ],\n    [ 232, 233, 234 ]]]\n\n>>> const L1 = nd.la.triu(A);\n>>> console.log( L1.toString() );\n[[[ 110, 111, 112 ],\n  [   0, 122, 123 ],\n  [   0,   0, 134 ]],\n [[ 210, 211, 212 ],\n  [   0, 222, 223 ],\n  [   0,   0, 234 ]]]\n>>> const L2 = nd.la.triu(A,+1);\n>>> console.log( L2.toString() );\n[[[ 0, 111, 112 ],\n  [ 0,   0, 123 ],\n  [ 0,   0,   0 ]],\n [[ 0, 211, 212 ],\n  [ 0,   0, 223 ],\n  [ 0,   0,   0 ]]]\n";
nd.la.diag_mat.__doc__ = "Creates a (main) diagonal matrix with the given diagonal values.\n\nParameters\n----------\ndiag: NDArray[...,N]\n  The diagonal values.\n\nReturns\n-------\nD: NDArray[...,N,N]\n  Such that `D(i,j) == i==j ? diag(i) : 0`.\n\nExamples\n--------\n>>> const D = nd.la.diag_mat([[1,2,3],[4,5,6]]);\n>>> console.log( D.toString() );\n  [[[ 1, 0, 0 ],\n    [ 0, 2, 0 ],\n    [ 0, 0, 3 ]],\n   [[ 4, 0, 0 ],\n    [ 0, 5, 0 ],\n    [ 0, 0, 6 ]]]\n";
nd.la.matmul.__doc__ = "Computes the matrix product of a series of matrices. The order\nof multiplications is optimized to minimize the number of floating\npoint operations required. The last two axes are considered to be\nthe matrix dimensions. For the leading axes, broadcasting rules apply.\nAlong with `nd.la.matmul2`, this is one of the only two methods\nthat currently allows complex inputs.\n\nParameters\n----------\nmatrices: ...NDArray\n  The matrices that are to be multiplied.\n\nReturns\n-------\nproduct: NDArray\n  Where `product = matrices[0] @ matrices[1] @ ... @ matrices[n-1]`.\n\nExamples\n--------\n>>> const v = nd.tabulate([1e6,1], () => 1);\n>>> console.log( v.toString() );\n  [[ 1 ],\n   [ 1 ],\n   [ 1 ],\n   [ 1 ],\n   [ 1 ],\n   ...999990 more...,\n   [ 1 ],\n   [ 1 ],\n   [ 1 ],\n   [ 1 ],\n   [ 1 ]]\n>>> const u = nd.la.matmul(v,v.T,v,v.T,v);\n>>> console.log( u.toString() );\n  [[1000000000000],\n   [1000000000000],\n   [1000000000000],\n   [1000000000000],\n   [1000000000000],\n   ...999990 more...,\n   [1000000000000],\n   [1000000000000],\n   [1000000000000],\n   [1000000000000],\n   [1000000000000]]\n";
nd.la.matmul2.__doc__ = "Computes the matrix product of exactly two matrices. The last two axes\nare considered to be the matrix dimensions. For the leading axes,\nbroadcasting rules apply. Along with `nd.la.matmul`, this is one\nof the only two methods that currently allows complex inputs.\n\nParameters\n----------\na: NDArray[...,N,K]\n  The left factor matrices.\nb: NDArray[...,K,M]\n  The right factor matrices.\n\nReturns\n-------\nproduct: NDArray[...,N,M]\n  Where `product = a @ b`.\n\nExamples\n--------\n>>> const A = [\n...   [2, 0],\n...   [0,-1]\n... ];\n>>> const x = nd.array([\n...   [[1,2]],\n...   [[3,4]],\n...   [[5,6]]\n... ]).T;\n>>> console.log( x.toString() );\n  [ [[1],\n     [2]],\n\n    [[3],\n     [4]],\n\n    [[5],\n     [6]] ]\n>>> const y = nd.la.matmul2(A,x);\n>>> console.log( y.toString() );\n  [ [[ 2 ],\n     [-2 ]],\n  \n    [[ 6 ],\n     [-4 ]],\n  \n    [[10 ],\n     [-6 ]] ]\n";
nd.la.cholesky_decomp.__doc__ = "Computes the Cholesky Decomposition of an `NDArray` of symmetric, positive\ndefinite (square) matrices. The implementation assume the matrices to be symmetric\nand only looks at the lower triangular values. The last two axes of the `NDArray`\nare considered to be the matrix dimensions.\n\nParameters\n----------\nS: NDArray[...,N,N]\n  An `NDArray` of symmetric, positive definite (square) matrices. In other words\n  S is symmetric and has only positive eigenvalues. \n\nReturns\n-------\nL: NDArray[...,N,N]\n  A lower triangular matrix, such that `S = L @ L.T`.\n\nExamples\n--------\n>>> const S = [\n...   [ 25, -50],\n...   [-50, 101]\n... ];\n>>> const L = nd.la.cholesky_decomp(S);\n>>> console.log( nd.la.matmul2(L,L.T).toString() );\n  [[ 25, -50],\n   [-50, 101]]\n";
nd.la.cholesky_solve.__doc__ = "Given a cholesky decomposition and the right hand side of a linear equation system,\nthis method computes the result of said system.\n\nParameters\n----------\nL: NDArray[...,N,N]\n  An array of lower triangular (square) matrices. L is assumed to be lower triangular\n  without looking at the upper triangular values.\ny: NDArray[...,N,M]\n  The right hand side of the linear equations system.\n\nReturns\n-------\nx: NDArray[...,N,M]\n  Such that `L @ L.T @ x == y`.\n\nExamples\n--------\n>>> const S = [\n...   [ 25, -50],\n...   [-50, 101]\n... ];\n>>> const y = [\n...   [[1],\n...    [2]],\n...   [[3],\n...    [4]]\n... ];\n>>> const L = nd.la.cholesky_decomp(S);\n>>> const x = nd.la.cholesky_solve(L,y);\n>>> console.log( nd.la.matmul2(S,x) );\n [[[1.0],\n   [2.0]],\n  [[3.0],\n   [4.0]]]\n";
nd.la.tril_solve.__doc__ = "Given the lower triangular (square) matrix and the right hand side of a linear\nequation system, this method computes the result.\n\nParameters\n----------\nL: NDArray[...,N,N]\n  The lower triangular matrix of the linear equations system. L is assumed to\n  be lower triangular without ever looking at the values in the upper triangular\n  region.\ny: NDArray[...,N,M]\n  The right hand side matrix of the linear equation system.\n\nReturns\n-------\nx: NDArray[...,N,M]\n  Such that `L @ x = y`.\n";
nd.la.triu_solve.__doc__ = "Given the upper triangular (square) matrix and the right hand side of a linear\nequation system, this method computes the result.\n\nParameters\n----------\nU: NDArray[...,N,N]\n  The upper triangular matrix of the linear equations system. U is assumed to\n  be upper triangular without ever looking at the values in the lower triangular\n  region.\ny: NDArray[...,N,M]\n  The right hand side matrix of the linear equation system.\n\nReturns\n-------\nx: NDArray[...,N,M]\n  Such that `U @ x = y`.\n";
nd.la.lu_decomp.__doc__ = "Given an `NDArray` of square matrices, this method Computes the\nLU(P) decomposition with Column Pivotization.\n\nParameters\n----------\nA: NDArray[...,N,N]\n\nReturns\n-------\nLU: NDArray[...,N,N]\n  A matrix containing both the lower and upper triangular part of the\n  LU decomposition. The diagonal of ther lower triangular matrix L\n  is not contained in LU. It only containes ones and is implied.\nP : NDArray[...,N]\n  The order in which the row indices of A appear in the LU decomposition, i.e.:\n  `A(P[i],j) == (L @ U)[i,j]`.\n";
nd.la.lu_solve.__doc__ = "Given the LU(P) decomposition and the right hand side of a\nLinear Equations System, this method computes the result of\nsaid system.\n\nParameters\n----------\nLU: NDArray[...,N,N]\nP : NDArray[...,N]\ny : NDArray[...,N,M]\n\nReturns\n-------\nx : NDArray[...,N,M]\n  The solution of the Linear Equation System, such that:\n  `y[P[i],:] == (L @ U @ x)[i,:] `\n";
nd.la.qr_decomp_full.__doc__ = "Computes the (full) QR Decomposition of a matrix. The QR\nDecomposition can be used to solve both Linear Equations\nand Linear Least Square problems with high numeric accuracy.\nUnder normal circumstances, the incomplete QR Decomposition\n(`nd.la.qr_decomp`) is to be preferred over this method\nas it may be significantly more memory efficient.\n\nParameters\n----------\nA: NDArray[...,N,M]\n  The matrix for which the QR Decomposition is computed.\n\nReturns\n-------\nQ: NDArray[...,N,N]\n  An orthogonal square matrix, i.e. `Q @ Q.T == Q.T @ Q == nd.la.eye(N)`.\nR: NDArray[...,N,M]\n  An upper triangular matrix, such that: `A = Q @ R`\n";
nd.la.hessenberg_decomp.__doc__ = "Computes the (Upper) Hessenberg Decomposition of a matrix. It\nis worth mentioning that the Hessenberg Decomposition of a\nsymmetric matrix is tridiagonal.\n\nParameters\n----------\nA: NDArray[...,N,N]\n  The matrix for which the Hessemberg Decomposition is computed.\n\nReturns\n-------\nU: NDArray[...,N,N]\n  An orthogonal matrix, i.e. `U @ U.T == U.T @ U == nd.la.eye(N)`.\nH: NDArray[...,N,N]\n  An upper Hessemberg matrix, i.e. `nd.la.tril(H,-2) == 0`, such that `U @ H @ U.T == A`.\n";
nd.la.eigen.__doc__ = "Returns the eigenpairs of a real square matrix.\n\nParameters\n----------\nA: NDArray[...,N,N]\n  The non-symmetric real squre matrix for which the eigenvalues are computed.\n\nReturns\n-------\n\u039B: NDArray[...,N]\n  A matrix containing all eigenvalues.\nV: NDArray[...,N,N]\n  A matrix containing the eigenvectors corresponding to \u039B as columns, i.e.:\n  `\u039B[i]*V[j,i] == (A @ V)[j,i]`.\n  The columns are normalized using the 2-norm. \n";
nd.la.schur_decomp.__doc__ = "Computes the (real) Schur Decomposition of a matrix. The\nSchur Decomposition is used to compute the Eigenvalues and\nEigenvectors.\n\nParameters\n----------\nA: NDArray[...,N,N]\n\nReturns\n-------\nQ: NDArray[...,N,N]\n  An orthogonal square matrix.\nT: NDArray[...,N,N]\n  An upper quasi-triangular matrix, such that `Q @ T @ Q.T == A`.\n  The diagonal of T consists of 2x2 blocks that represent complex\n  eigenpairs and 1x1 matrix that represent a real eigenvalue.\n";
nd.la.qr_decomp.__doc__ = "Computes the (economic) QR Decomposition of a matrix. The\nQR Decomposition can be used to solve both Linear Equations\nand Linear Least Square problems with high numeric accuracy.\nUnder normal circumstances, this method is to\nbe preferred over the full QR Decomposition (`nd.la.qr_decomp_full`)\nas it may be significantly more memory efficient.\n\nParameters\n----------\nA: NDArray[...,N,M]\n  The matrix for which the QR Decomposition is computed.\n\nReturns\n-------\nQ: NDArray[...,N,min(N,M)]\n  An orthogonal rectangular matrix, i.e. `Q.T @ Q == nd.la.eye(min(N,M))`.\nR: NDArray[...,min(N,M),M]\n  An upper triangular matrix, such that: `A = Q @ R`\n";
nd.la.rrqr_decomp.__doc__ = "Computes the economic Rank-Revealing QR Decomposition of a matrix.\n\nParameters\n----------\nA: NDArray[...,N,M]\n  The matrix for which the QR Decomposition is computed.\n\nReturns\n-------\nQ: NDArray[...,N,min(N,M)]\n  An orthogonal rectangular matrix, i.e. `Q.T @ Q == nd.la.eye(min(N,M))`.\nR: NDArray[...,min(N,M),M]\n  An upper triangular matrix, where `R[i,i] >= R[j,j]` if and only if `i <= j`.\nP: NDArray[...,M]\n  The permuted column indices, such that:\n  `(Q @ R)[:,j] == A[:,P[j]]`\n";
nd.la.qr_lstsq.__doc__ = "Given the QR Decompostion and the right hand side of a full-rank\nlinear equation system, this method solves it. If the Linear\nEquation System is under-determined, the Linear Least Square\nsolution is computed. This method is no suited for rank-deficient\nor under-determined systems, in which case `rrqr_lstsq` or\n`svd_lstsq` can be used instead.\n\nParameters\n----------\nQ: NDArray[...,N,K]\n  The orthognal rectangular matrix of the QR Decomposition.\nR: NDArray[...,K,M]\n  The upper triangular matrix of the QR Decomposition.\ny: NDArray[...,N,L]\n  The right hand side of the Linear Equation System.\n\nReturns\n-------\nx: NDArray[...,N,L]\n  Such that `\u2016(Q @ R @ x) - y\u2016\u2082` is minimal.\n";
nd.la.bidiag_decomp.__doc__ = "Computes the Upper Bidiagonal Decomposition of a matrix. Bidiagonal\nDecomposition is a common preprocessing step for the Singular Value\nDecomposition.\n\nParameters\n----------\nA: NDArray[...,N,M]\n  The matrix for which the Upper Bidiagonal Decomposition is\n  computed.\n\nReturns\n-------\nU: NDArray[..., N, min(N,M)]\n  An orthognal rectangular matrix.\nB: NDArray[..., min(N,M), N >= M ? M : N+1 ]\n  An upper bidiagonal rectangular matrix.\nV: NDArray[..., N >= M ? M : N+1, M]\n  An orthogonal rectangular matrix. Such that `A = U @ B @ V @`\n";
nd.la.solve.__doc__ = "Solves a full-rank Linear Equations System (LES). The method tries to\ndetect rank-deficient systems and throw a `SingularMatrixSolveError`,\nwhich contains some least squares solution to the rank-deficient\nsystem as property `x`.\n\nParameters\n----------\nA: NDArray[...,N,K]\n  The matrix of the LES.\ny: NDArray[...,K,M]\n  The right hand side of the LES.\n\nReturns\n-------\nx: NDArray[...,N,M]\n  The solution of `(A @ x) = y`.\n";
nd.la.svd_decomp.__doc__ = "Computes the Singular Value Decomposition (SVD) of a matrix.\n\nParameters\n----------\nA: NDArray[...,N,M]\n  The matrix for which the SVD is computed.\n\nReturns\n-------\nU : NDArray[...,N,min(N,M)]\n  An orthogonal, rectangular matrix.\nsv: NDArray[..., min(N,M) ]\n  The singular values of A sorted in descending order.\nV : NDArray[...,min(N,M),M]\n  An orthogonal, rectangular matrix, such that `A == U @ diag(sv) @ V`.\n";